# Anchor Selector Configuration
# Main configuration file for both popup app and launcher system

# =================================================================
# APPLICATION SETTINGS
# =================================================================
# 
# ALIAS FUNCTIONALITY:
# Commands with action "alias" have special behavior - when the user types
# text that exactly matches an alias command name, the input text is 
# automatically replaced with the alias argument. This allows creating
# shortcuts like: gh -> url https://github.com
popup_settings:
  max_rows: 15
  max_columns: 3
  use_new_launcher: false  # Enable new Rust launcher (false = Python launcher)
  debug_log: "~/.anchor.log"  # Debug logging file path (empty/null to disable)
  # Command editor dropdown actions (comma-separated list)
  # Users can reorder, add, or remove actions to customize the dropdown
  listed_actions: "app,url,folder,cmd,chrome,safari,brave,firefox,work,notion,obs,obs_url,1pass,1pass_old,1pass_robust,anchor,alias,doc,contact"
  # Enable merging of similar commands (true = merge "Analysis Folder", "Analysis Note" -> "Analysis...")
  merge_similar: true
  # Characters used as word separators for command parsing and merging
  word_separators: " ._-"
  # Root directory for file system scanning (F7 key functionality)
  scan_root: "~/"
  # Seconds between automatic filesystem scans (default: 10)
  scan_interval_seconds: 10

# Markdown file scanning roots (for F7 key functionality)
# List of directories to scan for markdown files
# These will be added as commands with "obs" or "anchor" actions
markdown_roots:
  - "~/Documents"
  - "~/Notes"
  # Add more directories as needed

# Launcher settings
settings:
  default_browser: "Google Chrome"
  work_browser: "Google Chrome Beta"
  timeout_ms: 5000

# =================================================================
# FUNCTIONS (when use_new_launcher: true)
# =================================================================
# Unified section for all function types:
# - Simple functions: defined as mappings {fn: function_name, ...}
# - JavaScript functions: defined as strings containing JS code
#
# The launcher automatically detects the type based on the value format.

functions:
  # Basic actions - implemented as Rust built-ins (single-line format)
  action_app: {fn: launch_app, name: "{{arg}}"}             # app Finder -> launches Finder
  action_url: {fn: open_url, url: "{{arg}}"}                # url https://github.com -> opens in default browser
  action_folder: {fn: open_folder, path: "{{arg}}"}         # folder /Applications -> opens folder
  action_cmd: {fn: shell, command: "{{arg}}"}               # cmd echo hello -> executes shell command
  action_doc: {fn: open_with, app: "", arg: "{{arg}}"}      # doc ~/file.txt -> opens with default app
  
  # Browser-specific actions - implemented as Rust built-ins (single-line format)
  action_chrome: {fn: open_with, app: "Google Chrome", arg: "{{arg}}"}      # chrome https://github.com -> opens in Chrome
  action_safari: {fn: open_with, app: "Safari", arg: "{{arg}}"}             # safari https://apple.com -> opens in Safari
  action_brave: {fn: open_with, app: "Brave Browser", arg: "{{arg}}"}       # brave https://brave.com -> opens in Brave
  action_firefox: {fn: open_with, app: "Firefox", arg: "{{arg}}"}           # firefox https://mozilla.org -> opens in Firefox
  action_work: {fn: open_with, app: "Google Chrome Beta", arg: "{{arg}}"}   # work https://company.com -> opens in work browser
  
  # Specialized app actions - implemented as Rust built-ins (single-line format)  
  action_notion: {fn: open_with, app: "Notion", arg: "{{arg}}"}             # notion notion://page -> opens in Notion
  action_obs_url: {fn: open_with, app: "Obsidian", arg: "{{arg}}"}          # obs_url obsidian://vault -> opens in Obsidian
  
  # Contact action - opens contact in Contacts app
  action_contact: {fn: open_with, app: "Contacts", arg: "addressbook://{{arg}}"}  # contact <id> -> opens contact
  
  
  # 1Password using simple Quick Access (original approach, kept for compatibility)
  action_1pass_old:
    fn: shell
    command: "osascript -e 'tell application \"System Events\" to keystroke \" \" using {shift down, command down}' && sleep 0.3 && osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"' && sleep 0.2 && osascript -e 'tell application \"System Events\" to key code 36'"
  
  # === JAVASCRIPT FUNCTIONS (defined as strings) ===
  # These use JavaScript with rich built-in functions.
  # For complete API documentation, see src/js_runtime.rs module.
  #
  # Command Context Variables:
  #   {{arg}} - Command argument (template substitution in YAML)
  #   ARG - Command argument (JavaScript variable)
  #   ACTION - Action name (e.g., "anchor", "obs")
  #   FULL_COMMAND - Complete original command (e.g., "anchor /tmp")
  #   COMMAND - JSON object with all command metadata
  # alias NAME - Text replacement and recursive command calling
  # Special behavior: When user types an exact match for an alias command name,
  # the input text is automatically replaced with the alias argument.
  # If executed normally, it recursively calls launch() with the argument.
  action_alias: 'launch("{{arg}}")'
  
  # Complex JavaScript functions - multi-line format
  action_obs: |
    const encoded = encodeURIComponent("{{arg}}");
    const url = `obsidian://open?vault=kmr&file=${encoded}`;
    launch_app("Obsidian", url);
  
  # anchor PATH - User-customizable anchor activation
  action_anchor: |
    // This calls the user-customizable activate script
    // Users can edit src/business_logic/activate.js to customize behavior
    const path = "{{arg}}";
    change_directory(path);
    
    // Load and execute the activate script
    // In the full implementation, this would call the activate_anchor function
    log("Activating anchor: " + path);
    
    // For now, implement basic functionality inline
    // Users can override this entirely by editing the activate.js script
    open_folder(path);
    
    const anchorName = basename(path);
    const tmuxConfig = path + "/.tmuxp.yaml";
    
    if (fileExists(tmuxConfig)) {
      log("Found tmux config: " + tmuxConfig);
      
      // Try to read the session name from the tmuxp config
      let sessionName = anchorName;
      try {
        const configContent = readFile(tmuxConfig);
        // Simple regex to find session_name in YAML
        const match = configContent.match(/session_name:\s*(.+)/);
        if (match && match[1]) {
          sessionName = match[1].trim();
          // Remove quotes if present
          sessionName = sessionName.replace(/^["']|["']$/g, '');
          log("Using session name from config: " + sessionName);
        } else {
          log("No session_name found in config, using directory name: " + sessionName);
        }
      } catch (e) {
        log("Could not read tmuxp config, using directory name: " + sessionName);
      }
      
      // Just try to create/attach to tmux session
      log("Working with tmux session: " + sessionName);
      
      // Activate iTerm and attach to session
      activateApp("iTerm2");
      shell("tmux attach-session -t \"" + sessionName + "\"");
    } else if (fileExists("CLAUDE.md")) {
      log("Found CLAUDE.md, starting Claude Code");
      start_claude_code();
    }
  
  # 1pass NAME - 1Password with multiple fallback approaches (main implementation)
  action_1pass: |
    // Try Quick Access first (most universal)
    try {
      shell("osascript -e 'tell application \"System Events\" to keystroke \" \" using {shift down, command down}'");
      shell("sleep 0.3");
      shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
      shell("sleep 0.2");
      shell("osascript -e 'tell application \"System Events\" to key code 36'");
    } catch (e) {
      // Fallback 1: Try menu bar access
      try {
        shell("osascript -e 'tell application \"System Events\" to tell process \"1Password 7 - Password Manager\" to click menu bar item 1 of menu bar 1'");
        shell("sleep 0.5");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
        shell("osascript -e 'tell application \"System Events\" to key code 36'");
      } catch (e2) {
        // Fallback 2: Open 1Password app and use search
        shell("osascript -e 'tell application \"1Password\" to activate'");
        shell("sleep 0.5");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"f\" using command down'");
        shell("sleep 0.2");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
        shell("osascript -e 'tell application \"System Events\" to key code 36'");
      }
    }
  
  # 1pass_robust NAME - 1Password with multiple fallback approaches
  1pass_robust: |
    // Try Quick Access first (most universal)
    try {
      shell("osascript -e 'tell application \"System Events\" to keystroke \" \" using {shift down, command down}'");
      shell("sleep 0.3");
      shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
      shell("sleep 0.2");
      shell("osascript -e 'tell application \"System Events\" to key code 36'");
    } catch (e) {
      // Fallback 1: Try menu bar access
      try {
        shell("osascript -e 'tell application \"System Events\" to tell process \"1Password 7 - Password Manager\" to click menu bar item 1 of menu bar 1'");
        shell("sleep 0.5");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
        shell("osascript -e 'tell application \"System Events\" to key code 36'");
      } catch (e2) {
        // Fallback 2: Open 1Password app and use search
        shell("osascript -e 'tell application \"1Password\" to activate'");
        shell("sleep 0.5");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"f\" using command down'");
        shell("sleep 0.2");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
        shell("osascript -e 'tell application \"System Events\" to key code 36'");
      }
    }

  # Helper functions (shared with JavaScript actions)
  
  # Replace hardcoded iTerm activation with user-customizable version
  activate_iterm: |
    activateApp("iTerm2");
  
  # Replace hardcoded Claude Code launcher with flexible version
  start_claude_code: |
    if (commandExists("claude")) {
      return spawnDetached("claude", "--continue");
    } else {
      return "Claude Code not available in PATH";
    }
  
  # Replace hardcoded tmux session check with configurable version  
  has_tmux_session: |
    const sessionName = arguments[0];
    if (!commandExists("tmux")) {
      return false;
    }
    const result = JSON.parse(shellWithExitCode(`tmux has-session -t "${sessionName}" 2>/dev/null`));
    return result.exitCode === 0;
  
  # Replace hardcoded tmux session starter with flexible version
  start_tmux_session: |
    const configPath = arguments[0];
    if (!commandExists("tmuxp")) {
      log("tmuxp not available, falling back to tmux");
      // Could implement fallback tmux logic here
      return "tmuxp not available";
    }
    const expanded = expandHome(configPath);
    log("Loading tmuxp config: " + expanded);
    
    // First check if the file exists
    if (!fileExists(expanded)) {
      return "Tmuxp config file not found: " + expanded;
    }
    
    // Load the tmuxp config in detached mode
    const result = JSON.parse(shellWithExitCode(`tmuxp load "${expanded}" -d`));
    if (result.exitCode === 0) {
      log("Tmuxp output: " + result.stdout);
      return `Started tmux session from: ${expanded}`;
    } else {
      log("Tmuxp stderr: " + result.stderr);
      return `Failed to start tmux session: ${result.stderr}`;
    }
  
  # Example: Custom browser selection based on URL
  smart_browser: |
    const url = arguments[0];
    if (testRegex(url, "github\\.com")) {
      launch_app("Google Chrome", url);
      return "Opened GitHub URL in Chrome";
    } else if (testRegex(url, "company\\.com")) {
      launch_app("Google Chrome Beta", url); // Work browser
      return "Opened work URL in Chrome Beta";
    } else {
      open_url(url);
      return "Opened URL in default browser";
    }
  
  # Example: Environment-aware terminal activation
  activate_terminal: |
    if (appIsRunning("iTerm2")) {
      return activateApp("iTerm2");
    } else if (appIsRunning("Terminal")) {
      return activateApp("Terminal");
    } else {
      launch_app("iTerm2");
      return "Launched iTerm2";
    }

# =================================================================
# GRABBER RULES
# =================================================================
# Rules for capturing application context and creating commands
# Each rule has:
# - name: Display name for the rule
# - matcher: JavaScript that returns arg string if matched, null if not
# - action: Action type for the created command
# - group: Optional group for the command

grabber_rules:
  # Chrome/Brave browser URLs
  - name: "Chrome URL"
    matcher: |
      if (bundleId === "com.google.Chrome" && props.url) {
        return props.url;
      }
      return null;
    action: "url"
    
  - name: "Brave URL"
    matcher: |
      if (bundleId === "com.brave.Browser" && props.url) {
        return props.url;
      }
      return null;
    action: "url"
    
  # Safari URL with special handling
  - name: "Safari URL"
    matcher: |
      if (bundleId === "com.apple.Safari" && props.url) {
        return props.url;
      }
      return null;
    action: "safari"
    
  # Finder folder
  - name: "Finder Folder"
    matcher: |
      if (bundleId === "com.apple.finder" && props.path) {
        return props.path;
      }
      return null;
    action: "folder"
    
  # Obsidian note (based on window title)
  - name: "Obsidian Note"
    matcher: |
      if (app === "Obsidian" && title) {
        // Extract note name from window title
        const match = title.match(/^(.+?) - Obsidian/);
        if (match) {
          return match[1];
        }
      }
      return null;
    action: "obs"
    
  # VS Code file (based on window title)
  - name: "VS Code File"
    matcher: |
      if (bundleId === "com.microsoft.VSCode" && title) {
        // Extract file path from window title
        const match = title.match(/^(.+?) [—–] /);
        if (match) {
          return match[1];
        }
      }
      return null;
    action: "doc"
    
  # Generic document (fallback for other apps)
  - name: "Generic Document"
    matcher: |
      // For apps with a window title that looks like a document
      if (title && !title.includes("http") && title.length > 3) {
        // Skip browser-like titles
        if (bundleId.includes("browser") || bundleId.includes("chrome") || bundleId.includes("safari")) {
          return null;
        }
        // Return the window title as a document reference
        return title;
      }
      return null;
    action: "doc"