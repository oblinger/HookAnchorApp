# Journal.2007\_01\_19a --

    BL languages

    WHAT DOES NOT MATTER:

    - speed.  (as long as we can optimize later)

    - compile time type checking.  (but code readability does)


    WHAT DOES MATTER

    - Coding time
    - Refactoring simplicity
    - Not taking design choices for expediency new that paint us in a corner, for later.
    - Generality/Simplicity
      - IL-Objects operating in all ways like their printed form
      - No separate state
      - Mix and match different types of accessors, e.g. use type-specific write accessor, followed immediately by
        a IL-object generic accessor on the same field.
      - Different processes using differnt accessors on same type of object.
      - Any deep refactoring or re-implementation, or different usage on IL objects consistent with the printed form
        should be "easy" to do.


    Shared IL object scenerio
      - Three learning processes destructively operating on a very large common BLC representing current beliefs
      - Java and C in shared memory; LISP process via TCP pipe.
      - One process is destrutively modifying, while others are watching


    Templating Scenerio:
    - Specification of world state, with 3 parameters, which looks in source code very much like
      the printout of the world state would, in interlingua   (Templating)






    PROPOSAL

    IL-OBJECT CLASS
    new IL-Object()    Not used for technical reasons
    * static IL-Object create(String type) 
       This method actually looks at the 'type' string to decide what subclass to return
    * getIL
    * getInt
    * getString
    * getNthIL(int n, String field)
      ...
    * setIL(String field, ILObject obj)
    * ... 
    * All Java Map operators   (e.g. IL-Object implements Map)
    * Helper methods for flexible construction of large structures of IL objects.  
      (Explicit Templating support in separate helper classes)


    Classes that extend IL-Object all look like this:

    public class Foo extends ILObject <<>>
       ...
    }



    * Super fast to code and refactor.
    * Later we can turn these things into "real" java objects if needed
      without recoding any code that interfaces with these classes as long as that code uses the local accessors.
    * These objects always behave like the printed form. because they almost *are* the printed form.
    * Outside the IL hierarchy these will "feel" like real java objects, since we will be using normal java
      accessors.  Inside the IL hierarchy I dont think we should have code there.  We should *not* use OO design on IL objects 
      themselves, we should employ helper classes like Java Collections.
