# HookAnchor Default Configuration
# 
# This file is automatically generated from the developer's personal config.
# Personal paths have been replaced with generic defaults suitable for new users.
# 
# Copy this to ~/.config/hookanchor/config.yaml and customize as needed.
#
# UNIFIED ACTIONS SYSTEM:
# All behaviors (templates, keyboard bindings, command actions) are now defined
# in the 'actions:' section. Each action has a 'type' that determines its behavior,
# and can optionally be bound to a keyboard key via the 'key' field.

# Anchor Selector Configuration.
# Main configuration file for both popup app and launcher system

# =================================================================
# APPLICATION SETTINGS
# =================================================================
popup_settings:
  max_rows:               25          # Max number of rows in the list of matching commands
  max_columns:            4           # Max columns in list of matching commands
  verbose_logging:        false       # Controls if detailed logging messages are printed
  merge_similar:          true        # Merging similar commands in popup
  word_separators:        " ._-"      # Word separator chars submenus and merging
  scan_interval_seconds:  30          # How many seconds between automatic rescanning of the filesystem
  idle_timeout_seconds:   3600          # Auto-close after 60 seconds of inactivity (default)
  countdown_seconds:      5           # Seconds for grabber countdown (default: 5)
  run_in_background:      true        # Keep app running in background for instant popup (experimental)
  popup_server_retries:   3           # Number of times to retry showing the popup before rebuilding
  max_window_size:        "1700x1100" # Maximum size for dialogs and popups in "widthxheight" format
  default_window_size:    "600x400"   # Default popup window size in "widthxheight" format
  max_log_file_size:      10000000    # Maximum log file size in bytes (10MB) before clearing
  listed_actions: >
    alias,anchor,app,url,folder,cmd,chrome,safari,brave,firefox,work,
    notion,obs,obs_url,1pass,rewrite,doc,contact,slack,text,shutdown,tmux_activate

launcher_settings:
  js_timeout_ms:          5000        # Max milliseconds allows for a js command execution
  obsidian_app_name:      "Obsidian"  # Obisidian app name
  obsidian_vault_name:    "MyVault"       # Main vault used for Obsidian viewing of markdown files
  obsidian_vault_path:    "~/Documents/Notes"  # Location of the main vault

scanner_settings:

markdown_roots:
 - "~/Documents/Notes"                         # Markdown file scanning roots
 - "~/Documents"
 - "~/Notes"


# =================================================================
# KEYBOARD SHORTCUTS 
# =================================================================
# Key name formats:
#   - Single keys: "Escape", "Enter", "Space", "Delete", "/", "="
#   - Arrow keys: "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"  
#   - Letters: "A", "B", "C" (automatically normalized to uppercase)
#   - Chords: "Cmd+C", "Ctrl+/", "Cmd+Equals", "Alt+Shift+Plus"
# Uncomment lines below to customize:

keybindings:
  exit_app:             "Escape"      # Exit the application (only when no sub-interfaces are open)
  navigate_down:        "ArrowDown"   # Move selection down
  navigate_up:          "ArrowUp"     # Move selection up
  navigate_left:        "ArrowLeft"   # Move selection left (multi-column)
  navigate_right:       "ArrowRight"  # Move selection right (multi-column)
  execute_command:      "Enter"       # Execute the selected command
  force_rebuild:        "`"           # Force rebuild: restart server + rescan (backtick) - ASCII form works now!
  show_folder:          "/"           # Launch first folder matching search - ASCII form works now!
  open_editor:          "="           # Open command editor - ASCII form works now!
  edit_active_command:  ";"           # Edit currently selected command - word form
  show_keys:            "?"           # Show all available key bindings - ASCII form works now!
  tmux_activate:        "Cmd+T"       # Start tmux session in selected anchor's folder
  
  # Chord key examples showing both ASCII and word forms work:
  # copy_selection: "Cmd+C"    # Copy selected command
  # paste_text: "Cmd+V"        # Paste from clipboard  
  # save_config: "Ctrl+="      # Save configuration - ASCII form in chord
  # find_command: "Ctrl+Slash" # Focus search field - word form in chord
  # new_template: "Cmd+-"      # Create new template - ASCII form in chord
  # quick_action: "Cmd+Shift+Plus" # Quick action menu - word form in chord


# =================================================================
# TEMPLATES - For creating new commands & files
# =================================================================
templates:
  # Default template - creates a basic anchor command
  default:
    key: "%"
    name: "{{input}}"
    action: "anchor"
    arg: "/path/to/{{input}}/{{input}}.md"
    patch: "{{selected_patch}}"
    flags: ""
    edit: true
    description: "Create new anchor command"
    
  # Note template - creates dated notes
  note:
    description: "Create dated note in Notes folder"
    key: "$"
    name: "{{YYYY}}-{{MM}}-{{DD}} {{input}}"
    action: "markdown"
    arg: "~/Notes/{{YYYY}}/{{MM}}/{{YYYY}}-{{MM}}-{{DD}} {{input}}.md"
    patch: "Notes"
    edit: true
    file: "~/Notes/{{YYYY}}/{{MM}}"
    contents: |
      # {{YYYY}}-{{MM}}-{{DD}} {{input}}
      
      Created: {{YYYY}}-{{MM}}-{{DD}} {{hh}}:{{mm}}
      
      
  # Quick grab template - captures current window after delay
  grab:
    description: "Capture window/app after 3 second countdown"
    key: "+"
    grab: 3
    name: "{{input}}"
    action: "{{grabbed_action}}"
    arg: "{{grabbed_arg}}"
    edit: true
    group: "Apps"
    
  # Alias template - creates alias to previously executed command
  alias:
    description: "Create alias to last executed command"
    key: ">"
    name: "{{input}}"
    action: "alias"
    arg: "{{previous_name}}"
    patch: "{{previous_patch}}"
    flags: ""
    edit: true
    
  # Sub-anchor template - creates anchor as subfolder of last command's folder
  sub_anchor:
    description: "Create anchor as subfolder of last command's folder"
    key: "!"
    name: "{{input}}"
    action: "anchor"
    arg: "{{previous_folder}}/{{input}}/{{input}}.md"
    patch: "{{previous_patch}}"
    flags: ""
    edit: true
    file: "{{previous_folder}}/{{input}}"
    validate_previous_folder: true
    contents: |
      .[[{{input}}]].  >[[{{previous_name}}]]
      
  # WW template - creates work sub-anchor with YYYY-MM prefix
  ww:
    description: "Creates a ww subfolder with YYYY prefix"
    key: "Ctrl+W"
    name: "{{YYYY}} {{input}}"
    action: "anchor"
    arg: "~/Work/{{YYYY}} {{input}}/{{YYYY}} {{input}}.md"
    patch: "WW"
    flags: ""
    edit: true
    file: "~/Work/{{YYYY}} {{input}}.md"
    file_rescan: true
    contents: |
      .[[{{YYYY}}-{{MM}} {{input}}]].
      
      
  # Prj template - creates work sub-anchor with YYYY-MM prefix
  prj:
    description: "Create work sub-anchor with YYYY-MM prefix"
    key: "Ctrl+P"
    name: "{{YYYY}} {{input}}"
    action: "anchor"
    arg: "~/Projects/{{YYYY}} {{input}}/{{YYYY}} {{input}}.md"
    patch: "WW"
    flags: ""
    edit: true
    file: "~/Projects/{{YYYY}} {{input}}.md"
    file_rescan: true
    contents: |
      .[[{{YYYY}}-{{MM}} {{input}}]].
      
      


# =================================================================
# GRABBER RULES
# =================================================================
# Rules for capturing application context and creating new commands

grabber_rules:
  # =================================================================
  # BROWSER APPLICATIONS
  # =================================================================
  
  # Google Chrome
  - name: "Chrome URL"
    matcher: "bundleId === 'com.google.Chrome' && props.url ? props.url : null"
    action: "chrome"
    group: "Web"
    
  # Safari
  - name: "Safari URL"
    matcher: "bundleId === 'com.apple.Safari' && props.url ? props.url : null"
    action: "safari"
    group: "Web"
    
  # Brave Browser
  - name: "Brave URL"
    matcher: "bundleId === 'com.brave.Browser' && props.url ? props.url : null"
    action: "brave"
    group: "Web"
    
  # Firefox
  - name: "Firefox URL"
    matcher: "bundleId === 'org.mozilla.firefox' && props.url ? props.url : null"
    action: "firefox"
    group: "Web"
    
  # Chrome Beta (work browser)
  - name: "Chrome Beta URL"
    matcher: "bundleId === 'com.google.Chrome.beta' && props.url ? props.url : null"
    action: "work"
    group: "Work"
  
  # =================================================================
  # FILE SYSTEM & DOCUMENTS
  # =================================================================
  
  # Smart Finder rules using recommendedAction from get_action function
  
  # Finder anchor files (markdown files matching folder name)
  - name: "Finder Anchor"
    matcher: "bundleId === 'com.apple.finder' && props.selection && props.recommendedAction === 'anchor' ? props.selection : null"
    action: "anchor"
    group: "Files"
    
  # Finder markdown files (other markdown files)  
  - name: "Finder Markdown"
    matcher: "bundleId === 'com.apple.finder' && props.selection && props.recommendedAction === 'markdown' ? props.selection : null"
    action: "markdown"
    group: "Files"
    
  # Finder executables
  - name: "Finder Executable"
    matcher: "bundleId === 'com.apple.finder' && props.selection && props.recommendedAction === 'cmd' ? props.selection : null"
    action: "cmd"
    group: "Cmd"
    
  # Finder documents (other file types)
  - name: "Finder Document"
    matcher: "bundleId === 'com.apple.finder' && props.selection && props.recommendedAction === 'doc' ? props.selection : null"
    action: "doc"
    group: "Doc"
    
  # Finder selected folder
  - name: "Finder Selected Folder"
    matcher: "bundleId === 'com.apple.finder' && props.selection && props.recommendedAction === 'folder' ? props.selection : null"
    action: "folder"
    group: "Dir"
    
  # Finder current folder (when no selection)
  - name: "Finder Path"  
    matcher: "bundleId === 'com.apple.finder' && !props.selection && props.path ? props.path : null"
    action: "folder"
    group: "Dir"
    
  # VS Code files
  - name: "VS Code File"
    matcher: "bundleId === 'com.microsoft.VSCode' && title && !title.includes('Welcome') ? title.split(' — ')[0] : null"
    action: "doc"
    group: "Code"
    
  # Xcode projects
  - name: "Xcode Project"
    matcher: "bundleId === 'com.apple.dt.Xcode' && title ? title.split(' — ')[0] : null"
    action: "doc"
    group: "Code"
    
  # Sublime Text files
  - name: "Sublime Text File"
    matcher: "bundleId === 'com.sublimetext.4' && title && title !== 'Sublime Text' ? title.split(' • ')[0] : null"
    action: "doc"
    group: "Code"
    
  # TextEdit documents
  - name: "TextEdit Document"
    matcher: "bundleId === 'com.apple.TextEdit' && title && title !== 'TextEdit' ? title : null"
    action: "doc"
    group: "Documents"
  
  # =================================================================
  # PRODUCTIVITY APPLICATIONS
  # =================================================================
  
  # Obsidian notes - gets active file URL via enriched context
  - name: "Obsidian Note"
    matcher: "bundleId === 'md.obsidian' && props.url ? props.url : null"
    action: "obs_url"
    group: "Notes"
    
  # Notion pages
  - name: "Notion Page"
    matcher: "bundleId === 'notion.id' && props.url ? props.url : null"
    action: "notion"
    group: "Notes"
    
  # Bear notes
  - name: "Bear Note"
    matcher: "bundleId === 'net.shinyfrog.bear' && title && title !== 'Bear' ? title : null"
    action: "doc"
    group: "Notes"
    
  # 1Password items
  - name: "1Password Item"
    matcher: "bundleId.includes('1password') && title && !title.includes('1Password') ? title.split(' — ')[0] : null"
    action: "1pass"
    group: "Security"
  
  # =================================================================
  # TERMINAL & DEVELOPMENT
  # =================================================================
  
  # Terminal sessions
  - name: "Terminal Session"
    matcher: "bundleId === 'com.apple.Terminal' && title && title !== 'Terminal' ? title : null"
    action: "cmd"
    group: "Terminal"
    
  # iTerm2 sessions
  - name: "iTerm2 Session"
    matcher: "bundleId === 'com.googlecode.iterm2' && title ? title.split(' — ')[0] : null"
    action: "cmd"
    group: "Terminal"
    
  # Tmux sessions (when visible in terminal title)
  - name: "Tmux Session"
    matcher: "title && title.includes('tmux') ? title.match(/tmux\\[(\\w+)\\]/)?.[1] : null"
    action: "cmd"
    group: "Terminal"
  
  # =================================================================
  # COMMUNICATION & COLLABORATION
  # =================================================================
  
  # Slack channels/DMs - captures channel name and uses slack action
  - name: "Slack Channel"
    matcher: "bundleId === 'com.tinyspeck.slackmacgap' && props.channel ? props.channel : null"
    action: "slack"
    group: "Slack"
    
  # Discord servers
  - name: "Discord Server"
    matcher: "bundleId === 'com.hnc.Discord' && title && !title.includes('Discord') ? title : null"
    action: "app"
    group: "Communication"
    
  # Zoom meetings
  - name: "Zoom Meeting"
    matcher: "bundleId === 'us.zoom.xos' && title && title.includes('Zoom Meeting') ? 'Zoom Meeting' : null"
    action: "app"
    group: "Meetings"
  
  # =================================================================
  # MEDIA & DESIGN
  # =================================================================
  
  # Photoshop documents
  - name: "Photoshop Document"
    matcher: "bundleId === 'com.adobe.Photoshop' && title && !title.includes('Adobe Photoshop') ? title.split(' @ ')[0] : null"
    action: "doc"
    group: "Design"
    
  # Figma files
  - name: "Figma File"
    matcher: "bundleId === 'com.figma.Desktop' && title && !title.includes('Figma') ? title.split(' – ')[0] : null"
    action: "doc"
    group: "Design"
    
  # Sketch documents
  - name: "Sketch Document"
    matcher: "bundleId === 'com.bohemiancoding.sketch3' && title && !title.includes('Sketch') ? title : null"
    action: "doc"
    group: "Design"
  
  # =================================================================
  # SYSTEM & UTILITIES
  # =================================================================
  
  # Activity Monitor processes
  - name: "Activity Monitor Process"
    matcher: "bundleId === 'com.apple.ActivityMonitor' && title && title !== 'Activity Monitor' ? title : null"
    action: "app"
    group: "System"
    
  # Console logs
  - name: "Console Log"
    matcher: "bundleId === 'com.apple.Console' && title && title !== 'Console' ? title : null"
    action: "app"
    group: "System"
    
  # System Preferences panes
  - name: "System Preferences"
    matcher: "bundleId === 'com.apple.systempreferences' && title && title !== 'System Preferences' ? title : null"
    action: "app"
    group: "System"
  
  # =================================================================
  # FALLBACK RULES
  # =================================================================
  
  # # Generic application with meaningful window title
  # - name: "Application with Document"
  #   matcher: "title && title.length > 3 && !title.includes(app) && !title.includes('Welcome') ? title : null"
  #   action: "doc"
  #   group: "Documents"
    
  # Test command for debugging CMD logging
  - name: "Test Command"
    matcher: "false"
    action: "cmd"
    group: "Test"
    
  # Generic application launcher
  - name: "Application Launcher"
    matcher: "app && app.length > 0 ? app : null"
    action: "app"
    group: "Apps"


# =================================================================
# FUNCTIONS
# =================================================================
# Unified section for all function types:
# - Simple functions: defined as mappings {fn: function_name, ...}
# - JavaScript functions: defined as strings containing JS code
#
# The launcher automatically detects the type based on the value format.
#
# NAMING CONVENTION:
# - Action functions (callable via commands) use "action_" prefix
# - Helper functions (for internal use) use descriptive names without prefix
# Example: "action_app" implements the "app" action, "has_tmux_session" is a helper

functions:

  # Browser-specific actions
  action_chrome: {fn: open_with, app: "Google Chrome", arg: "{{arg}}"}      # chrome https://github.com -> opens in Chrome
  action_safari: {fn: open_with, app: "Safari", arg: "{{arg}}"}             # safari https://apple.com -> opens in Safari
  action_brave: {fn: open_with, app: "Brave Browser", arg: "{{arg}}"}       # brave https://brave.com -> opens in Brave
  action_firefox: {fn: open_with, app: "Firefox", arg: "{{arg}}"}           # firefox https://mozilla.org -> opens in Firefox
  action_work: {fn: open_with, app: "Google Chrome Beta", arg: "{{arg}}"}   # work https://company.com -> opens in work browser
  
  # Specialized app actions
  action_notion: {fn: open_with, app: "Notion", arg: "{{arg}}"}             # notion notion://page -> opens in Notion
  action_obs_url: {fn: open_with, app: "Obsidian", arg: "{{arg}}"}          # obs_url obsidian://vault -> opens in Obsidian
  action_obs: {fn: shell_sync, command: "open -a Obsidian && /bin/sleep 0.1 && open 'obsidian://open?vault=kmr&file={{arg}}'"}  # obs FILE -> opens in Obsidian
  action_contact: {fn: open_with, app: "Contacts", arg: "addressbook://{{arg}}"}  # contact <id> -> opens contact
  

  # === SIMPLE FUNCTIONS (defined as mappings) ===
  # Basic actions
  action_app: {fn: launch_app, name: "{{arg}}"}                      # app Finder -> launches Finder
  action_url: {fn: open_url, url: "{{arg}}"}                         # url https://github.com -> opens in default browser
  action_folder: |
    const folderPath = "{{arg}}";
    log(`FOLDER: Starting with path: '${folderPath}'`);
    
    // Check if path is already absolute (starts with / or ~)
    if (folderPath.startsWith('/') || folderPath.startsWith('~')) {
      // Already absolute, use as-is
      log(`FOLDER: Using absolute path: '${folderPath}'`);
      try {
        open_folder(folderPath);
        log(`FOLDER: Successfully called open_folder for: '${folderPath}'`);
      } catch (error) {
        log(`FOLDER: Error opening folder: ${error}`);
      }
    } else {
      // Relative path - join with vault root
      const vaultRoot = getObsidianVaultPath();
      const absolutePath = joinPath(vaultRoot, folderPath);
      log(`FOLDER: Converting relative path '${folderPath}' to absolute: '${absolutePath}'`);
      try {
        open_folder(absolutePath);
        log(`FOLDER: Successfully called open_folder for: '${absolutePath}'`);
      } catch (error) {
        log(`FOLDER: Error opening folder: ${error}`);
      }
    }
  # cmd COMMAND - Execute shell command (add W flag for windowed execution: cmd W echo hello)  
  action_cmd: |
    const fullCmd = "{{arg}}";
    
    // Check if command starts with 'W ' flag (handle different separations)
    if (fullCmd.startsWith('W ')) {
      // Remove 'W ' and get actual command  
      const command = fullCmd.substring(2);
      log(`CMD: Executing in Terminal window (W flag): '${command}'`);
      
      // Use osascript to open Terminal window with command
      // Escape both single and double quotes for AppleScript
      const escapedCmd = command.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "'\"'\"'");
      shell(`osascript -e 'tell application "Terminal" to do script "${escapedCmd}"'`);
      
      // Brief delay to ensure Terminal has time to start
      shell_sync("/bin/sleep 0.2");
      
      log(`CMD: Terminal window opened with command`);
    } else if (fullCmd.startsWith('W; ')) {
      // Handle 'W; ' format (semicolon with space)
      const command = fullCmd.substring(3);
      log(`CMD: Executing in Terminal window (W; flag): '${command}'`);
      
      // Use osascript to open Terminal window with command
      const escapedCmd = command.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "'\"'\"'");
      shell(`osascript -e 'tell application "Terminal" to do script "${escapedCmd}"'`);
      
      // Brief delay to ensure Terminal has time to start  
      shell_sync("/bin/sleep 0.2");
      
      log(`CMD: Terminal window opened with command`);
    } else if (fullCmd.startsWith('W;')) {
      // Handle 'W;' format (semicolon no space)
      const command = fullCmd.substring(2);
      log(`CMD: Executing in Terminal window (W; flag): '${command}'`);
      
      // Use osascript to open Terminal window with command
      const escapedCmd = command.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "'\"'\"'");
      shell(`osascript -e 'tell application "Terminal" to do script "${escapedCmd}"'`);
      
      // Brief delay to ensure Terminal has time to start  
      shell_sync("/bin/sleep 0.2");
      
      log(`CMD: Terminal window opened with command`);
    } else {
      // Normal background execution
      log(`CMD: Executing in background: '${fullCmd}'`);
      shell(fullCmd);
    }
  action_doc: {fn: open_with, app: "", arg: "{{arg}}"}               # doc ~/file.txt -> opens with default app
  # markdown FILE - Open markdown files, use Obsidian if within vault
  action_markdown: |
    const filePath = "{{arg}}";
    log(`MARKDOWN: Processing file: '${filePath}'`);
    
    // Get the Obsidian vault path and expand it
    const vaultPath = getObsidianVaultPath();
    log(`MARKDOWN: Obsidian vault path: '${vaultPath}'`);
    
    // Normalize the file path (expand ~ and resolve ..)
    const normalizedFilePath = expandHome(filePath);
    const normalizedVaultPath = expandHome(vaultPath);
    
    log(`MARKDOWN: Normalized file path: '${normalizedFilePath}'`);
    log(`MARKDOWN: Normalized vault path: '${normalizedVaultPath}'`);
    
    // Check if the file is within the Obsidian vault
    if (normalizedFilePath.startsWith(normalizedVaultPath + '/') || normalizedFilePath === normalizedVaultPath) {
      // File is in Obsidian vault - open in Obsidian
      log(`MARKDOWN: File is in Obsidian vault, opening in Obsidian`);
      
      // Get the relative path from vault root
      const relativePath = normalizedFilePath.substring(normalizedVaultPath.length + 1);
      log(`MARKDOWN: Relative path in vault: '${relativePath}'`);
      
      // Remove .md extension if present
      const fileNameWithoutExt = relativePath.replace(/\.md$/, '');
      
      // Encode for URL
      const encoded = encodeURIComponent(fileNameWithoutExt);
      const vault = getObsidianVault();
      const app = getObsidianApp();
      const url = `obsidian://open?vault=${vault}&file=${encoded}`;
      
      log(`MARKDOWN: Opening Obsidian with URL: ${url}`);
      launch_app(app, url);
    } else {
      // File is outside vault - open with default markdown editor
      log(`MARKDOWN: File is outside Obsidian vault, opening with default app`);
      shell(`open "${filePath}"`);
    }
  

  # text FILE - Type contents of a text file into the focused application
  action_text: |
    const filePath = "{{arg}}";
    log(`TEXT: Reading file: '${filePath}'`);
    
    // Read the file contents
    let content;
    try {
      content = readFile(filePath);
      log(`TEXT: Successfully read ${content.length} characters from file`);
    } catch (error) {
      log(`TEXT: Error reading file: ${error}`);
      throw new Error(`Failed to read text file: ${error}`);
    }
    
    // Give focus back to the previous application (the one that was active before popup)
    log(`TEXT: Switching focus to previous application`);
    shell("osascript -e 'tell application \"System Events\" to key code 48 using command down'");
    shell_sync("/bin/sleep 0.5"); // Wait for focus switch
    
    // Type the content using a simpler approach
    log(`TEXT: Typing content into focused application`);
    
    // Use AppleScript to type the content as a single string
    // This is faster and should complete more reliably
    const escapedContent = content
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/'/g, "\\'");
    
    const script = `osascript -e 'tell application "System Events" to keystroke "${escapedContent}"'`;
    
    try {
      shell_sync(script);
      log(`TEXT: Successfully typed content`);
    } catch (error) {
      log(`TEXT: Error typing content: ${error}`);
      throw new Error(`Failed to type text: ${error}`);
    }
  
  # shutdown SCRIPT - Execute shutdown script without blocking the UI
  action_shutdown: |
    // Use spawnDetached to run shutdown commands that won't block the UI or system shutdown
    spawnDetached("{{arg}}");
  
  # 1Password using simple Quick Access (original approach, kept for compatibility)
  # Uses Cmd+Shift+Space to open Quick Access, types search term, presses Enter
  action_1pass_old: {fn: shell_sync, command: "osascript -e 'tell application \"System Events\" to keystroke \" \" using {shift down, command down}' && /bin/sleep 0.3 && osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"' && /bin/sleep 0.2 && osascript -e 'tell application \"System Events\" to key code 36'"}
  
  # === JAVASCRIPT FUNCTIONS (defined as strings) ===
  # These use JavaScript with rich built-in functions.
  # For complete API documentation, see src/js_runtime.rs module.
  
  # rewrite NAME - Recursive command calling
  action_rewrite: |
    launch("{{arg}}");
  
  # anchor PATH - Open anchor markdown file in Obsidian (simplified like markdown action)
  action_anchor: |
    const fullPath = "{{arg}}";
    const anchorDir = fullPath.substring(0, fullPath.lastIndexOf('/'));
    
    log(`ANCHOR: Opening anchor at: ${fullPath}`);
    log(`ANCHOR: Directory: ${anchorDir}`);
    
    // Change to the anchor directory (keeping this for context)
    change_directory(anchorDir);
    
    // Just open the markdown file in Obsidian - no folder browsing or tmux activation
    const baseName = fullPath.split('/').pop().replace(/\.md$/, '');
    const encoded = encodeURIComponent(baseName);
    const vault = getObsidianVault();
    const app = getObsidianApp();
    const url = `obsidian://open?vault=${vault}&file=${encoded}`;
    log(`ANCHOR: Opening in Obsidian: ${url}`);
    launch_app(app, url);
  
  # 1pass NAME - 1Password with multiple fallback approaches (main implementation)
  action_1pass: |
    // Try Quick Access first (most universal)
    try {
      shell("osascript -e 'tell application \"System Events\" to keystroke \" \" using {shift down, command down}'");
      shell_sync("/bin/sleep 0.5");  // Increased delay for Quick Access to fully open
      // Type character by character for better reliability - fast but still controlled
      shell_sync(`osascript -e 'tell application "System Events"
        repeat with i from 1 to length of "{{arg}}"
          set currentChar to character i of "{{arg}}"
          keystroke currentChar
          delay 0.05
        end repeat
      end tell'`);
      shell_sync("/bin/sleep 0.3");  // Brief delay before Enter since typing is now complete
      shell("osascript -e 'tell application \"System Events\" to key code 36'");  // Press Enter to select and fill
      shell_sync("/bin/sleep 0.3");  // Longer delay after Enter
    } catch (e) {
      // Fallback 1: Try menu bar access
      try {
        shell("osascript -e 'tell application \"System Events\" to tell process \"1Password 7 - Password Manager\" to click menu bar item 1 of menu bar 1'");
        shell_sync("/bin/sleep 0.5");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
        shell("osascript -e 'tell application \"System Events\" to key code 36'");
      } catch (e2) {
        // Fallback 2: Open 1Password app and use search
        shell("osascript -e 'tell application \"1Password\" to activate'");
        shell_sync("/bin/sleep 0.5");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"f\" using command down'");
        shell_sync("/bin/sleep 0.2");
        shell("osascript -e 'tell application \"System Events\" to keystroke \"{{arg}}\"'");
        shell("osascript -e 'tell application \"System Events\" to key code 36'");
      }
    }
  
  # Helper functions (not directly callable as commands)
  
  start_claude_code: |
    if (commandExists("claude")) {
      return spawnDetached("claude", "--continue");
    } else {
      return "Claude Code not available in PATH";
    }
  
  # slack CHANNEL - Navigate to a specific Slack channel/DM
  action_slack: |
    const channel = "{{arg}}";
    // Use AppleScript to activate Slack and navigate to channel
    shell(`osascript -e 'tell application "Slack" to activate'`);
    shell_sync("/bin/sleep 0.5");
    // Open quick switcher with Cmd+K
    shell(`osascript -e 'tell application "System Events" to keystroke "k" using {command down}'`);
    shell_sync("/bin/sleep 0.5");
    // Type the channel name
    shell(`osascript -e 'tell application "System Events" to keystroke "${channel}"'`);
    shell_sync("/bin/sleep 0.5");
    // Press Enter to navigate
    shell(`osascript -e 'tell application "System Events" to keystroke return'`);

  # rescan - Force rescan of markdown files and filesystem
  action_rescan: |
    log("Forcing rescan of markdown files and filesystem...");
    // This will trigger a rescan in the popup application
    return "Rescan triggered";
    
  # Focus management functions for grabber
  give_up_focus: |
    // Give focus to the previous application using Cmd+Tab
    shell("osascript -e 'tell application \"System Events\" to key code 48 using command down'");
    shell_sync("/bin/sleep 0.15"); // Brief delay to ensure focus transfer completes
    
  regain_focus: |
    // Bring focus back to the anchor selector application
    shell("osascript -e 'tell application \"popup\" to activate'");
    shell_sync("/bin/sleep 0.1"); // Brief delay to ensure focus transfer completes
    
  # tmux_activate - Start tmux session in the selected anchor's folder (same as anchor command)
  action_tmux_activate: |
    // The arg contains the full path to the anchor markdown file
    const fullPath = "{{arg}}";
    const anchorDir = fullPath.substring(0, fullPath.lastIndexOf('/'));
    
    log(`TMUX_ACTIVATE: Checking for tmux session in: ${anchorDir}`);
    
    // Check if .tmuxp.yaml exists
    const tmuxpPath = joinPath(anchorDir, ".tmuxp.yaml");
    if (file_exists(tmuxpPath)) {
      log(`TMUX_ACTIVATE: Found .tmuxp.yaml at ${tmuxpPath}`);
      
      // Change to the anchor directory
      change_directory(anchorDir);
      
      const folderName = anchorDir.split('/').pop();
      log(`TMUX_ACTIVATE: Activating tmux session '${folderName}'`);
      
      try {
        // Get existing tmux sessions
        const sessionsResult = shellWithExitCode('/opt/homebrew/bin/tmux ls -F "#{session_name}" 2>/dev/null');
        const sessionsData = JSON.parse(sessionsResult);
        const existingSessions = sessionsData.exitCode === 0 ? 
            sessionsData.stdout.trim().split('\n').filter(s => s) : [];
        
        // Create session if it doesn't exist
        if (!existingSessions.includes(folderName)) {
          log(`TMUX_ACTIVATE: Creating session '${folderName}'`);
          const tmuxpResult = shell_sync(`tmuxp load "${tmuxpPath}" -d`);
          log(`TMUX_ACTIVATE: tmuxp load result: ${tmuxpResult}`);
          shell_sync("/bin/sleep 0.2");
        }
        
        // Try to attach to or switch to the session (same as anchor command)
        log(`TMUX_ACTIVATE: Attaching to session '${folderName}'`);
        try {
          // First try switch-client (works when already inside a tmux session)
          log(`TMUX_ACTIVATE: Trying tmux switch-client to '${folderName}'`);
          const switchResult = shellWithExitCode(`/opt/homebrew/bin/tmux switch-client -t "${folderName}"`);
          const switchData = JSON.parse(switchResult);
          
          if (switchData.exitCode === 0) {
            log(`TMUX_ACTIVATE: Successfully switched to session '${folderName}'`);
          } else {
            // switch-client failed, try attach-session (works when not inside tmux)
            log(`TMUX_ACTIVATE: Switch-client failed, trying attach-session to '${folderName}'`);
            const attachResult = shellWithExitCode(`/opt/homebrew/bin/tmux attach-session -t "${folderName}"`);
            const attachData = JSON.parse(attachResult);
            
            if (attachData.exitCode === 0) {
              log(`TMUX_ACTIVATE: Successfully attached to session '${folderName}'`);
            } else {
              log(`TMUX_ACTIVATE: Both switch-client and attach-session failed for '${folderName}'`);
              log(`TMUX_ACTIVATE: Switch error: ${switchData.stderr}`);
              log(`TMUX_ACTIVATE: Attach error: ${attachData.stderr}`);
            }
          }
        } catch (e) {
          log(`TMUX_ACTIVATE: Tmux execution error: ${e}`);
        }
        
        // Activate iTerm2 (same as anchor command)
        shell_sync("/bin/sleep 0.5");
        shell('osascript -e \'tell application "iTerm2" to activate\'');
        
      } catch (error) {
        log(`TMUX_ACTIVATE: Error with tmux session: ${error}`);
      }
    } else {
      log(`TMUX_ACTIVATE: No .tmuxp.yaml found at ${tmuxpPath}, skipping`);
    }

# Test unified actions
actions:
  test_url:
    type: "open_url"
    description: "Test opening URL"
    url: "https://github.com"
    
  test_folder:
    type: "open_folder"
    description: "Test opening folder"
    path: "/tmp"
    
  test_template:
    type: "template"
    description: "Test template action"
    name: "Test {{input}}"
    action: "test"
    arg: "/tmp/test_{{input}}.txt"
    patch: "Test"
    contents: |
      Test file for {{input}}
      Created at {{YYYY}}-{{MM}}-{{DD}}
