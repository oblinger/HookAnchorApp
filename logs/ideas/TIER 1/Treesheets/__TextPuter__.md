 https://www.geoffreylitt.com/
 
# ### INFO ###
## ### TARGET MARKETS ###
	- ENTERPRISE TEAM-BASED KNOWLEGE MANAGEMENT
	- POWER PIM USERS -- 
	- K WORKER TEAMS -- 
	- PROGRAMMABLE WORKFLOWS
	_
### === EKM -- ENTERPRISE TEAM-BASED KNOWLEGE MANAGEMENT ===

Emergent Quasi-Structure

**Context**: 
- Knowlege workers produce, organize, and use knowlege in the course of their knowledge work.
- Appropriate knowledge structures are not known in advance, and are not conserved across contexts (across time, across project, across users)

**Objective**: 
	Facilitate a knowledge-worker's use of an organization's knowledge and prior knowlege work for their task at hand.
	Facilitate use of an organization's prior knowledge work for task at hand

**Problem**: 

Sub Problems:
	FIND -- user has an idea of targeted info and wants to find matching docs & notes
	- hiearchies and names are a mishmash and not always aligned.
	ORGANIZE -- create & fill structure ideal for the K processing task
	- TASK: tracking status; reporting status; 
	REPORT STATUS -- 
	

KEY ASPECTS:
- Data lives in disparate forms and places
_
#### -- Data Types --

Paradigms:
- NOTES -- a collection graph info tied to a single node which can be losslessly reduced to text.
- TYPES -- a templated structure for a kind of information that is repeatedly instantiated to encode K
- LISTS -- a possibly ordered set of type instances
- STEPS -- a flow structure defined over type instances

Steps, Parts, Tasks, 

Types graph
- GROUP -- a graph node that stands in for a collection of nodes
	- ACTIVITY TREE -- a thing that is or could be performed over some period of time.
		- TASK -- an activity that leads some specified outcome.
			- OUTCOME -- a part of a task that specified the objective (artifact or state of world) desired.
	- ARTEFACT TREE -- a thing that can be produced
		- STATE OUTCOME -- a state of affairs the could be produced by some activity.  (litter is picked up)
		- COMPONENT -- a specific physical or virtual entity that could be created.

_
#### -- DATA CONNECTORS --

- GOOGLE DOCS / FOLDERS / SHEETS
- CONFLUENCE STRUCTURE

_
#### -- USAGE EXAMPLE: PROJECT LIFECYCLE --

PROJECT LIFECYCLE:
- Stakeholder Request --> Proposal --> Detailed Pre-Plan --> Sprint Planning --> Task Tracking Delivery docs


LIST REUSE
- one manager maintains a list of projects that are devs are currently billing against for tracking
- another manager has a hiearchy view of the 2021 roadmap parts of which map to first list
- individual dev has details about several projects they are working on


INFO FUSE
- multiple folks write about different aspects of a same thing


_

#### -- USAGE STORY --

DATA
- PROJECT LIFECYCLE: Request --> Proposal --> Detailed Pre-Plan --> Sprint Planning --> Task Tracking -> Final docs
- PARTS DAG
- TASKS DAG
- LOG



- REQUEST
	-- Client requests work to be done, or senior VP/CTO proposes new direction for the company
	-- These are fleshed out in a document where a portion of that document are sub-parts to build
	
- PROPOSED WORK PLAN
	-- The planned work plan (e.g. PDD).  
	-- Formal work plan document (w. formal structure like sizings etc.)
	
- DETAILED "WATERFALL" WORK PLAN

- SPRINT PLANNING

- DELIVERED ARTEFACT




EXTRA-ORG-WORK
- alignment of flow artifacts into a common parts containment hierarchy


ACTIVITIES
- Tracking status

_
### === PROGRAMMABLE WORKFLOWS ===
#### --- FLOW VIEWS ---
	- TRELLO VIEW
	- LIST VIEW
	- PROJECT-SLICE VIEW
	- TABLE VIEW
	_
### === K WORKER TEAMS ===

	- CUBE-TREE QUASI-FUSING -- 
	_
## === TOPICS ===
### --- Patent ---
	-- consumer-facing programmable, n-putation, for K.M.

	_
# ### TEXTPUTER ###
## === ELEVATOR ===
### --- ELEVATOR1 ---

EMERGENT ORGANIZATION -- org is progressively derived as needed by each user of the system

DECL

GTD / LIVE


_
### --- ELEVATOR2 ---

Interact with any info, from any app, in any other app, continuously re-organized in any way.


Plaintext Views

Ability to script knowlege info organization spanning multiple info apps

APPS: 	DOCS(gdocs,text,markdown,html)  SHEETS(Excel,gSheet)  PIM(Evernote,OneNote)
		KMTOOL(Confluence, 
		Sharepoint)
		BUGTRACKING()
		CRM()
## === GOALS / PRINCIPLES ===
### --- QUASI-SYNCHRONIZED VIEWS ---

_
### --- EMERGENT ORGANIZATION -- NO ONE IS IN CHARGE ---

Just as GIT did for Version Control, Textual Fabric does for KM.

- FORK -- It allows different users to have their own fork of the data where they are in full control of everything
- SEPARATED COPIES -- It is as if each user has a local copy of everything
- PROPAGATED BACK -- But changes are propagated back into 'master'

Just as with Git, each fork has an owner and that owner decides when/how pull requests are applied.

But unlike Git, this system is forking all the time, and multiple levels deep.

We avoid the centralization of control problem by letting users just organize as they need for their purposes.
Authorities above them can decide on a post-hoc basis to "annoint" certain organizing that certain users have done as not being part of their "master"

Importantly, just as with git.  There is not delegation of specific parts to specific people.  Any fork can can change any knowlege is any way it wants.  it fully owns its view of the universe.  and then pieces may be cherry picked or accepted enmass as needed.


~-~-~
Difference from Git.

AUTO PROPAGATION -- code is very precise and all parts of a complex app



_
### --- EMERGENT SCHEMA ---

SCHEMA -- A schema is a typing system for collections of information.  Each schema specifies typed fields for each instance within the collection.  Additionally each instance may specify mapping onto presentataions/mappings of the underlying data.

EMERGENT SCHEMA -- A schema is emergent in the sense that it exists within a graph of more and less specific verisons of the schema, and each version of the schema has data that has and has not been organized according to the emergent schema
_
### --- EMERGENT NAMING ---
- MERGED NAME SETS -- Like spotlight all names are merged into a single space
- 
### --- PURPOSE - GET SHIT DONE ---

- MISLEADING NAME -- Knowlege Management (KM) is a very misleading title for this field.  The goal is not and should not be to manage knowlege.  There is too much of it, and there are too many ways one might want to use the knowledge.  This is the wrong starting point.
- CORRECT GOAL -- The real KM object is to get stuff done, stuff that somehow requires knoweldge to complete.
- 

- ILLEGAL REQUIREMENTS -- Focus on getting shit done is one part ability (what does your tool afford) and what part requirements (what things does your tool force upon its user)
	- NEVER REQ MORE ORG/WORK THAN IS NEEDED FOR TASK AT HAND

_
### --- YOUR DATA / YOUR WAY ---

IDEA:  User says to her tool:  
	You are not the boss of me!  You are not better in all ways than all other tools!
	You don't know a one right way to organize my info, nor one right way to present it.  Let me be FREE!!!



APPROACH:
- Each piece of user info "lives" in the form and in the tool that they choose.
- You choose how to bucket your data -- this is independent of how it links etc. / word groups etc.
- Each piece lives in only one place, but is viewable and editable as if it exists in many forms and in many places.
- Best of all worlds, can pretend info was encoded in different ways in different places.


Example Case:
- I share notes with my team about potential clients in a dropbox folder by company name
- Use a google sheet to track status and ownership on some top of funnel emails and interactions
- I use files on my local drive as scratch space for early work
- I use Evernote to keep track of long running
- We use a google doc during meetings 


KEY REQUIREMENTS
- GRACEFUL BREAKING -- In theory it does not matter where losslessly transformable data lives, since it can always be converted.  In practice it DOES matter, connections break, permissions are lost, transmissions are delayed, transformations are corrupted, and then it DOES matter where the info lives.  In order to break gracefully we must all the user to choose on an info by info basis where they want it to live, so that info degrades in the way they want.

UNDERLYING ASSUMPTIONS
- ONE PLACE -- Info always 'exists' in exactly one place
- MANY VIEWS -- but may be _presented_ in many ways and in many places.
- WRITE THRU -- most views can be constructed so that most info can be edited within the view in a way that mostly seems at that moment as if the info is natively IN that view, while all changes are being written back to the actual  origin of that info
- CACHING -- in order to make this work performantly info is cached within various views and data dependencies graphs with 'dirty bits' are used to track and propagate this info.
- SEARCHING -- additionally full text search and other serach functions are supported by having separated 


_
### --- FINDING & FRAMING THINGS --- 

OBJECTIVE:  Given some knowlege-based performance task find the knowlege relevant to the task and frame (organize) the found knowledge in a way that best supports the performance task.

PROBLEM -- Finding some specific bit of info authored/organized/explored in the past


KEY IDEAS:
- NAMES -- Names are great since this is how our brain operates... it names things to keep them separate
- MESSY -- But namespaces are quite messy.  Named differently at different moments.
	- QUASI-ALIASES -- 
- LOCAL-GLOBAL
	- two ways to find...  linguistically, structurally
- INCREMENTAL MIGRATION
- NEVER REQUIRE MORE THAN NEEDED
- ALWAYS REUSE EARLIER EFFORTS

SEE NAMING THINGS)

_
### --- LOCAL ORG ---


ORG -- An org is an ordered DAG of containers into which a set of info items might be placed.

LOCAL ORG -- A local org is an org produced at a specific time over a specific info selection.


APPROACH
- Each local org may or may not reflect meta information back onto 

ORGING -- Introducing a relational structure over some existing information.

KEY CONSTRAINTS
- SEPARATE -- Org data is separate from but relates to underlying info node's data
	- Can be many org of the same underlying info

APPROACH
- User can drag unorged info into an evolving org
- User can drag org nodes in order to shape the org
- Meta info on the org indicates how its contents relate to the source info
	- Meta key tie to org nodes (e.g. the 'impt' org node would select and paint info nodes w/ that meta key)

_
#### -- TREE CUBE --

TREE CUBE -- A tree cube is a redundant collection of data cube axes arranged over the DAG of previously defined axes.

AXIS -- A tree cube axis specifies a selection of data overwhich is applies and is defined.  It has no meaning for information outside of this selection.  Within this selection is maps all node onto an axis value for that node.


Each org implicitly defines a new tree cube axis with each org node created.

_
### --- ZOOMING ---

SELECTION -- A selection is a specific subset of all available information which is explicitly indicated via a set of selection constraints.


SALIENT FACTS:  
- Work is often performed over an explicitly acknowleged highly limited selection of all available information
- Excluding information NOT in this explicitly acknowleged selection can greatly simplify info processing effort
- The relevant selection is not constant over time, nor over tasks
- Relevant selections do not form a simple partitions, nor singly linked trees, etc.
- Relevant selection at the time of information encoding, intermediate organizing and final usage need not be the same


LOCAL ORG is powerful
ORG REUSE is important (becuse of the cost of building local org)


THEREFORE 
- ORG is usually built within a specific selection (so much easier)
- TRANSFORMED ORG REUSE -- when operating in a selection that overlaps early one having local org, that org should be resued in for use in the new selection

ZOOMING -- the transformation and reuse of local orgs from prior selections in a new partially overlapping selection


HOW???
- TREE GRAFTING -- multiple local info trees may be tree grafted into a new whole by triming each of any info not in selection, and any info that has already been presented within one of the earlier grafts.  Grafting is performed recursively in the case that a single note exists within multiple subgraph trees.
- ACTIVE ZOOM -- at all times (info encoding, info processing, info presentation) the tool maintains an active zoom this selection is implicitly used to drive the info actions.  At a minimum it is used to ensure that info changes will present properly within the active view itself, but it may also have effect on info as seen from other zooms too.

_
### --- INCREMENTAL MIGRATION ---

_
### _
Aim: Present underlying text in all the right ways for task of the moment
- dd
- DB OPTO -- 
KEY IDEAS:
- Editable, Drag & Drop list/tree
- Multiple grain sizes
_

_
### LOCAL/GLOBAL INDEXING -------
### ONE SPACE - MANY PLACES -----
### TREE-TURTLES ALL THE WAY DOWN

NO LEAF NODES -- it is just trees all the way down.  
- More precisely, what counts as a "note", or an "individual" item, is itself a tree of info.
- Moreover from moment to moment, in each given display, what counts as an "individual item" can change in a very fluid way.
- Each tree node must explain how it would look if it where to be treated as a leaf
- And of course tree-structure itself explains how a node would when it is not a leaf
- This means that the tree can be sliced arbitrarily at any varying levels across its entirety

_
### RETRO INFO REORGING

Say what huh?
- An "info-reorg" is the action of taking one info org structure and produce a second info org structure from it.
- A retro "info-reorg" is to take an old info-reorg and reuse that info-reorg on new data.



Info Mgt is centrally about organizing info...
- Should be about org info for the task of the moment
- WHY:  too hard to know how data will be used differently in future.
- WHY:  one size does not fit all. why? info is expensive, don't collect nor decide if not going to use
- TWO big failure:  pre-org attempts, one-size-fits-all orging
There is not one single 'right' way to org info -- depends on moment in time, and goal of the moment
Info orgs need updating over time
Want to reuse the efforts of other organizing efforts within current effort


Current effort needs to produce an organization sufficient for the present goal at present time.
- not going to do 'extra' work now to 'prepare' data for some future task
- need to retro-actively fit prior data into currently require model

Desire to leverage prior info collect and prior info org-ing if it is relevant


TREE LAYER
- Transform of an info tree into a new info tree
- EDIT -- point edits of data values in order fit it into proper places in new (and maybe old) structures
- Should have a 'track changes' style control that indicates if original data is being edited.
- DRAG -- selectors of original data are pulled into new structure by drag operation
- Initial drag will be a 'live' connection to original data
- User can they edit the connection to:  auto push changes back, or to be a static copy of orig from that moment
- User can also select data
- User can reshape tree: (e.g. flatten x layers)
- RENAME -- user can apply some transform to the items
- rename is simplest, but any edit can be made
- MERGE -- user can merge nodes together 
- VARIABLIZATION -- A tree layer operation can be repeated
- Can be done programatically, by doing operation in a manual way, then specifying a repetition variables
	- Variables can be integers or tree places
- Concrete tree layer action is expressed as a spec
	- User clicks on tree-path-prefixes in expression, and/or integers in expression
- By default prefix will be varied across all descendents down one (or a certain level)
- By default integers will be varied across some semantically meaningful range
- Both can be updated to better values than default by user


_
### MARKET PLACE INFO REORGING
## === KEY IDEAS ===
### --- UNIFIED NAMING ---

- ASSUMED NOTE INFO  (all of this & its context determine a note's name)
	- NAME -- A unified (non-unique) pathed name.  (derived from info in note and its location)
	- PATH -- A unique path for each note (list of 8-bit clean strings)
	- TITLE -- A string title for note
	- TAGS -- A list of names
	- MAP -- Keys and values
	- BODY -- textual body

- SINGLE TREE OF NAMES -- All names exist in a single tree of names.
	- Each name is a list of name parts
	- Each name is case compressed alpha numeric and maps '_' onto space


- COMMON NAMING RULES
	- DOT -- title ending in '.' indiacates a name
	- BANG -- bang (!) embedded into a name title with an embedded indicates an overriding prefix
	- PATHNAME -- pathname / filename can be used as a name
	- TITLE -- title can override filename if indicating
	- META -- meta tag internal to note body can override title and filename
	- DISPOSITION -- entire subspace has 'disposition' in how its naming works
		- FLAT -- all names are merged into single space
		- TREE -- names are naturally nested by structure of space
		- IMPLICIT -- all notes generate a name implicitly
		- EXPLICIT -- only notes explicitly indicating will generate a name

- MERGE GROUP -- sub-tree of notes whose names are merged into single flat list
- IMPORT -- groups can import merge other groups
- SUBMENU -- merge group can be indicated as an item within another group

        #foo_bar		this is tag name
        title tag.		this is a title tag
        tit!le tag		this is a title with a prefix preference


any #foo_bar is a link to the indicated name.
_
### --- LIVE DATA ---

SOURCES:
- FILESYS
- GDOCS / GSHEETS
- GDRIVE, DROPBOX, etc.
- GITHUB

COMPUTE
- UNION -- one list is union of others.
- SELECT -- select list items
_
### --- ONE ITEM / MANY VIEWS ---
- Multiple grain sizes.  List.  just active.  One line summary.  just count
### --- NODE TYPING ---
### --- JUMP WORD ROUTING ---


>>>> union sets  (routing grouping that route together in single list)

NOTE: This is a re-invention-of and generalization-of the Zettelkasten "where to start" pages.


IMPLEMENTATION:
- CONTEXT
	- Notes may have a naming phrase
	- Notes may indiate that they represent 'top level page' potentially w a menu of sub notes
	- Sub notes are either direct children of a menu note, or indicate they are a subnote
- USER INTERFACE
	- A special 'jump to' key is used to begin a search for a named page to jump to
	- As user types this list is restricted to notes having matching prefixes
	- At all times the top n most common matching pages are shown in alpha order
	- At all times the first in this list is highligted, hitting RETURN will select it
	- If there is exactly one 'top level page' sharing this prefix it is always at the top
	- If space it hit and top is a menu page, then its sub-menu is shows 
	    (and prefix is shown in search bar.  So if user types m-u-s-space and music is a menu,
	     then "music> " is shown in the serach bar and the sub menu alternatives are displayed)
	- If space is hit and top entry is not a menu, then it is selected just as with RETURN
- REDUNDANCY
	- If two notes have the same name then the most recently edited one is presented and a links are added on the first line to each prior note (with comment suggesting to merge old notes in and/or rename them)


JUSTIFICATION
- Remembering a word to indicate a distant conceptual place is much easier than remembering local structure.
- AND global structures of disparate concepts is hard to generate and hard to navigate
- BUT finding unique names for dozens of shades of some big area is difficult and hard to remember
- AND local structure of related concepts is relavitely easy to create since relations are simple, 
	and easy to navigate since top of whole structure fits on a screen or two 
- SO a two level organzation is indicated.  The top level is not organized by tree, but rather by unique name.
	while the bottom is not organzied by name, but rather by local structure.


_
### --- MINIMUM REFERENCABLE CONTENT (MRC) ---


IMPLEMENTATION
- notes may supply a BINC-REG-TREE to segment a note implicitly into referencable chunks.
- Drag function can link to any internal or leaf node in this tree by dragging from that part of a note


JUSTIFICATION
- Central to understanding and processing information is the linking of that information.
- Central to Textputer is the idea of leveraging prior info efforts in later tasks.
- Thus reusing earlier linkages is important.  BUT:
	- linkage may or may not be correct in the future
	- what is being linking may change, so exactly what is being linked is no longer well defined.
- Thus need to keep an explicit boundary around thing references, so future editing can expliictly put info inside or outside that boundary.
- Hence MRCs.  Each MRC is a referenceable thing with some visually clear boundary.
- This allows future edits to be aware of this boundary and to implicitly include or exclude info by putting it inside or outside this boundary.
- SIMPLE -- hyper attention to the complexity of MRC management could become quite laborious and not worth the effort to get it 100% accurate.  So mostly getting linking mostly close the the correct target is the goal.
	- MRC segmenting is a very implict part of editing (e.g. just using a blank like or '~-~')
	- MRC maintaince is also implicit.  system tracks MRC regions during editing, but performs 'best effort' matching accross edits.  In some cases it will loose the exact MRC targets.
	- MRC merging and splitting will happen all the time, again system does best effort to keep links correct, but does not bother user to ensure they are correct.
	- MOVING MRCs is one counter example.  In some cases this system may prompt user if it is not sure about non-local movments since these links really can end up very far from their correct targets.

_
### --- QUASI-FUSED CUBE-TREES ---

CUBE-TREES -- Different people at different times provide grouping structure for the underlying data

STITCHED VIEW -- When viewing content a stitched view of content is provided by default.
- can focus on or ignore specific organizations
- can decide to extend from one
_
### --- SPLIT / SCOPE ---

SCOPE -- A scope is a specifies sub-potion of the data.  It indicates which sub-path(s) are in scope, it indicates which sub-time period(s) are in scope, it indicates the group of users' data that are in scope

SPLIT -- A split is a very basic building block of organization, ...

SPLIT SPEC --
- SCOPE a split is only defined over some specified scope.
- SHORTNAME a split has a shortname (no dots, can exist in many places)
- FULLNAME a split has a fullname (references a unique id in a global namespace )
- VALUES a split has an enumerate list of possible values (or a constrained datatype)
- PROPERTIES
	- PARTITIONING -- data items must exist in exactly ONE branch.  (have one value)


SEMANTICS
- Just because a split with a given fullname is defined one way at a given time by a given person does not limit how it might be defined at other times or by other people.

_
### --- FORK ---

FORK -- A fork is an annotated relationship between to sub-trees of data 
along with directional rules regarding propagation of changes

Each Direction may have:  
-- No propagation, 
-- Overwriting propagation, prompted/automatic over-writing/merging/delta-applying

_
### --- SCOPE - SCOPED VOCABULARY ---

SCOPED VOCABULARY -- 

SEMANTICS
- Lexspace is a tree of places where things may be located
- All entities exist in exactly one place at any moment in time
- Each subtree of lexspace is a scope
- Entities in a place under a scope is 'in' that scope
- Scopes are composable
- The KM system state is define as by the entities in it 'active' scope
- These entities define both the raw information managed by the KM system as well as all configuration and controls available to the KM system.

ENTITY FLAVORS
- INFO	--  Raw info
- FORK	--  A fork of the whole space
- ATTR	--  A node attribute with a binary, nary, or continuous value
- TYPE	--  A type of attr the inherits?
- SCOPE	-- 
- USER	-- 
- SCHEMA --  A named structure with named constrained sub-parts & layout
- VIEW	--  A possibly bi-directional mapping 


GROUP:	Info, Schema
DEF:	Attr, Type
+1:		Fork, Scope, User

_
### --- INTRINSIC AXES of organization --- 
- TIME - The time at which some content was authored
- TOPIC - A TREE taxononmy of topic/sub-topics that this content fits into
- TODO - The actions indicated by the context
- AUTHOR - The person/org writing the content
- TYPE - The type of the content (e.g. powerpoint, html, ...)

PROJECT - Intermediate level in the topic tree
VERSION - The version of some content (sub to time, and to topic)

Idea is that one should be able to reorder these primary axes and reorder content.

e.g. by topic down to level three, then by time

_
## === USE CASES ===
### --- MULTI-PERSON PROGRESSIVE ORGANIZATION ---

CONTEXT:
- ORGANIZING -- A users needs to organize some bits of info (a) within some specific sub context, 
	(b) over some period of time, (c) for some understood purpose.

USE CASE:
- MULTI-PARTY -- multiple people build hiearchies to redundantly organize info

CONTEXT
within a given context all containing trees are over-laid to produce a composite

GIVEN
- HYPERCUBE -- Data is embedded in a high dimensional hypercube.  (Finite but large number of axes)

- GRAFT -- A user defined a tree covering the data within some subcube
	- ENUMERATED SPLIT -- User just placed specific items within different sub-trees
	- LABELLED SPLIT -- User labelled a split with a new or existing label.
		This causes data to be updated to match the split value as it is moved, and 
		it automatically classifies all existing entries based on the split
		
- TAGGINGS -- A user may add/remove existing or created tags to items

- PATH TAGS -- A user may map certain path nodes onto graft splits & tag labellings

_
### --- INDEXING ---
INDEXING -- Scanning thru a body of information and organizing that information into a (typically new) index.

- The info may already be well organized against some other index.  This will not affect that index.
- The info may already be partially organized in ways that allow one to 'steal' sub tree or lists and copy them into this new structure w/o scanning the body of those structures, just moved wholesale (potentially with some edits)
- But naming in the new structure may be different and should be treated independently from the structure copied.

_
### --- MULTI-LEVEL FLAT LISTS ---

Given an implicit or explict containment DAG

MULTI-LEVEL FLAT LIST -- A _**multi-level flat list (MLFL)**_ is a collection of flat lists with an ordered "merge" DAG defined over them.


- Each list item which directly or indirectly appears in a flat list can be marked as visible within lists that contain this list according to the "merge" DAG.

- NO COST -- When no leveraging the benefits of MLFLs one should not incur any addition costs for using them.
	- AUTO PLACING -- Can add elements to list as if it were a simple flat list -- behaves properly
	- POST-FIXABLE W/O REBRAKING -- Can update auto-placement when other levels are considered to fix them w/o breaking original flat list as orginally understood
	- NO VISUAL LOSS -- An MLFL contains more information than a simple flat list, we avoid allowing that info to add  rows to the info presentation, or (much) complexity.
	- FRICTIONLESS MLFL UPDATING -- If one wishes to think of and update the MLFL one can do that directly from the simple flat list view.


VISUAL IMPLEMENTATION

- ABOVE THE FOLD -- the list is shown with an explicit "fold" marker (could simply be an empty list entry or such)
	- ABOVE -- Any items listed above the fold marker are visible by default.
- EDITING
	- DELETION -- deleting a merged list item simply moves it below the fold marker within it owning list.
	- INSERTION -- Insertion into a MLFL causes an insertion into the list owning the item above the insertion point.
	- EDIT -- Edits source list item by default, unless inclusion is a layer
- TITLE TWIDDLE CRUMBS
	- The MLFL DAG structure is shown in small grey characters injected between the list items of a MLFL
	- CLICK TTC -- Both mouse and keyboard can be used to "click" on these TTCs
		- HOVER -- TTC itself will highlight if mouse is hovered over it???
		- POPUP -- The click action causes a portion of the MLFL DAG roots at the TTC to be displayed as a popup
		- ARROW -- Each row has an '-->' icon that will highlight when hovered over.
					 RELEASE -- releasing over the arrow will insert an empty list item within that indicated list 
	- CLICK TTC ROOT -- 
		- POPUP -- The click generates a popup showing the DAG merge for this root node
		- CHECK -- Each row has a check mark showing if it is to be displayed within the merge list
		- SECOND CHECK -- Can have second check indicating full list inclusion
		- EXIT -- Clicking outside window or hitting space/esc/return will close popup


_
### --- CRISS-CROSS LISTS ---

CRISS-CROSS LIST -- A criss-cross list is some collection of list items organized simultaneously into two or more MLFLs.

	- EXAMPLE: items organized by project and also be due date


CRISS-CROSS VISULIZATION -- A criss-cross visualization presents information information according to a sequence of MLFLs.

	- SELECT -- Each MLFL is configured in the visualization to present some portion of its DAG.
				  Only items that match ALL MLFL are shown
	- SEQUENCING -- A set of MLFL roots can be 'sequenced' this means that a sequence of visualizations are produced each one as if that one sequenced item alone was selected.
	- CROSS SEQUENCING -- If two more more MLFL have sequences indicated the cross product of these visualizations is presented.


CRISS-CRISS DEFAULT -- A criss-cross default is a default assigment of some MLFL node from one DAG onto all children of some MLFL node from a second DAG

Example: Any item under client Enphase is automatically under 'clean energy' area






Example of natural MLFL
- Creation time is a natural MLFL
- Due date is a natural MLFL
- Priority is a natural MLFL
- Project/sub-project/sub-sub-part
- Client/client-VP-org/client-manager
- Area/sub-area







_
### --- POST ANNOTATING ---

typically in service of some organzational task one will re-frame and [re-]organize disparate material sources

LINKING -- providing a 3rd party (external) annotation that some how relates two or more places within prior organizations.
- RELATED TO
- INSTANCE OF
- SUB ITEM
# ### ARCHITECTURAL PIECES ###
## --- PIECES SUMMARY ---
- SCHEMA -- List of constrained table columns
- TAX -- An ordered DAG of predicates/containers, includes 'list'
- MARKDOWN -- 
- PILE -- A collection of stuff with ownership and permissions
## --- NOTE ---
pathname / shortname / title / bodytext / bodycontainerstructure
_
## --- NOTE PANE ---

A note pane is backed by a bi-directional mapping of unit onto text lines

This bi-d maps is defined by a grammar:
- SECTIONS -- fixed sections specifying a sub-note pane, and a derived sub-unit. (possbly by doing a 'get' on unit)
- KEYS -- an order sequence of key-value pairs
- TREE -- a mult-level list using integer keys of unit
- TEXT -- a single string used in an edit box tied to some expression of unit
_
## --- PANES - Text; Tree; Canvas ----
Note can be viewed using three different types of panes:
- TEXT -- This is a simple markdown text editor view (text may be BINC synthetic)
- TREE -- Note is 
- CANVAS --
_
### TEXT
- In special viewer, clicking will select the containing MRC
- Maybe can twiddle tree structure in text
## --- TEXT TREE PANE ---

TEXT
- DRAG -- This performs a text selection
- DRAG SELECTION -- will cut/paste raw text

BULLET
- BULLET CLICK -- will toggle node folding
- BULLET DRAG LEFT/RIGHT -- will change indention level
- BULLET DRAG UP/DOWN -- will move item within traversal
- 

DRAG
- Selects a source node
- Adds a modifier: linked-copy, copy, [direct-link is default]
_
## --- CHAR TREE - PREFIX TREE ---

PREFIX TREE -- A prefix tree organizes a set of named entries by nodes that represent common prefixes

- prefix menu shows all prefixes consistent with currently entered prefix
- ordered showing most commonly selected items at top of list
- All titles that end with '.' are considered a prefix word
- All titles that embed a '!' indicate a favored item once that prefix is entered it jumps to top of list

MERGE SETS:
- Any subtree can be indicated as a prefix word merge set.  Its titles will not be consider to be part of the containing merge set.
- Merge sets can be combined
- Merge sets can be triggered as a submenu from another merge set
- 

_
## --- TEXT - PLACED / WATCHED / STRUCTURAL STRING ---
### --- WATCHED UNIT ---
==> Relates to historical unit

_
## --- TAXONOMY / ALIGNMENT ---

**CONNECTION** -- A _**connection**_ is an annotation that somehow relates the contents of two or more notes in some way.

**ALIGNMENT** -- An _**alignment**_ is a possibly systematic collection of connections.

**LINKAGE** -- A _**linkage**_ is a kind of alignment or connection expressed as a select-transfer-inject rule

CONNECTION TYPES: Related, SubClass, Linked



TAXONOMY -- A taxonomy is a DAG of names
- For a given view (person) and time point, the taxonomy below a given node is well defined

_
## --- LAYER CUBE ---

Axes: User, Time, Place

_
## --- NPUTATION --- 
NPUTATION / BIPUTATION -- N-way computation.
INCREMENTAL NPUTATION / BIPUTATION -- 

_
## --- BINC TWE - BIPUTATITIVE - INCREMENTAL - TEXT-BASED WYSIWYG EDITABLE ---


Active element / configuration

BIPUTATIVE -- 

INCREMENTAL -- 


A TWE NPUTATIONS is one that is:
- TEXT BASED -- that is one side of the nputation is a text block
- WYSIWYG -- Both the textual side and all other sides can be edited in a natural WYSIWYG way.
- NATURAL -- Most or all expected WYSIWYG edit operations for each underlying data type are there
- RESPONSIVE -- Most or all edit operations result in expected underlying updates
- EDITABLE -- Most or all sides of the nputation supports natural edit operations


RESPONSIVE Caveat -- in some cases a BINC TWE is imposing some underlying structure that will limit the edits that are legal for some sides of the nputation, in that case the edit operations "get as close as they can" to what the unrestricted edit operation would do.  

True BINC TWEs require a naturalness to the edit operations, so it is expected that the user will be aware of the constraint being maintained, but the resulting edits need to be (1) expected and (2) natural


_
## --- BINC CACHED MAP ADAPTER ---

**BINC MAP ADAPTER** -- The _**binc map adapter**_ is used to build BINC units.  It is defined in terms of its iterator operator and its a set operator.

**BINC CACHED MAP ADAPTER** -- The _**binc cached map adapter**_ maintains a cached copy of a unit, then when synched will generated set operations backwards against the underlying unit.

- A cached map is defined in terms of: an underlying map with an iterator and a set operator.
- It scans the underlying unit and creates a backup copy and an exposed copy.
- External operations may view & manipulate the exposed copy.
- At any time a sync operation will compare the exposed and backup copies and generate a sequence of delta operations that will alter the backup copy to match the exposed copy.  These operations are also back-propagated to the underlying unit




_
## --- BINC TWE LIST ---
Biputative Incremental Text/List Mapping

**BINC LIST PARTITIONING** -- a _**binc list partition (BLP)**_ is a non-decreasing sequence of natural numbers.

This BLP defines a BINC TWE between a text block, T, and a list, L, of  of text blocks where each possibly empty text block in the list is mapped from the intervale
on either the text or the list can result in 

_
## --- BINC TWE REG-TRAVERSAL ---
- Biputative Incremental Treeification of a textual partitioning


IMPL
- Use 'get diff --patience' facility against a moving cached copy to generate a text.history() of edits
- Perform parallel moves to traversal.history() for wholly contained regex
- Reparse regex in sections that have changed use this to edit

_
## --- BINC TWE REG-LIST ---
BIPUTATIVE INCREMENTAL REGEX PARTITIONING ---
Links Text with list of match units.

**REG-LIST-PATTERN** -- A _**reg list pattern**_ is a list of simple regex expressions

_
## --- BINC TWE REG-MAP ---
Splits text into an ordered-map based on parameterized regex
_
## --- BINC TWE TABLE-MAP ---

TABLE-MAP-KEY-LIST -- A table map key list is a list of map keys which serve as the table columns


_
## --- BINC TREE/LIST FILTER ---

BINC CONJUNCT -- An incremental biputative conjunct maps a source list onto a target list that is a filtered subset of the source list where each element in the target list satisfies all listed conjuncts.  The conjucts are ordered and are evaluated in order, earlier conjuncts may derived values that are bound and used by later conjuncts.

The incremental biputative nature requires that arbitrary changes made to the target list can be "pushed backwards" into the source list.

- Deletion and editing of entries is handled straightforwardly as edits and deletions on the source side
- Insertions require the creation of entries that will satify the conjunct.

Here is how:
- Key equality is satified by just setting the key's value.
- biputative key equality is satisfied by pushing the value.
- location constraints are satified by having a designated and default insertion point so created entry will be within the selected set.  and/or usage of nearest current elements as a way to determine insertion location in the source.
- generalized push-based satisficers.  arbitray code that accepts a change at target and generates a matching source entry for some or all of the conjuncts.
## --- NINC TWE EXPR  ---

**NINC EXPR** -- A _**ninc twe expr**_ is an asyclic binc twe graph where each binc-twe node has one free side and n-1 grounded sides.

TREEVAR -- A treevar is a tree define via a grounded ninc expr.  (A tree var may)  (or list as special case)

NINC ROOT
- Has an NINC expr and n named children which are the root and leaves of this expr
- Each grounded side lists the source of the grounding
- Each free side contains the current content of that free ninc side

- A BINC TWE
- mapping TEXT onto TREE / LIST
- with optional reg-list patterning
- and optional list-tree filtering

_
## --- GRAPH TEMPLATE GRAMMARS ---

**TEMPLATE GRAMMAR** -- A _**template grammar (TG)**_ is a parametrically defined template structure expressible in both text and graph forms.

A template grammar is a text template that contains n distinct template vars.

These template vars may be bound to:
- A single value
- A list or tree of values (template is instantiated via the cross product of these parameters)
- A computed value (based on other template vars, and content of template)
- A sub-template
- an Or tree of these binding options
- A filter condition to remove certain combinations
- Graph structure is lazily constructed by instantiation of cross product of template var instances




graph template grammar
- NINC TWE graph structure is parametrically defined in terms of n input vars
- Input vars are mapping onto any treevar






Scripts that macro-expand recursive structures built from these synthetic pieces, based on base text to define the base layer.
_
## --- RETE ENGINE ---

needed later....

_
## === 2021.09.20 - WYSIWYG programmable data view
How hard would it be, to create a WYSIWYG-programmable, JS based, info.

_
### --- PARTS ---
### --- LIVE VALUES ---
Ability to specify a template structure with live values that itself is watched.
Entire interface is live and auto updates when assign (or sync) operations occur

- watchers, 
- dependent values (fn that eagerly/lazily watches)
- DOM values and key global-vars (like current plan) for most every part of interface
- 
### --- Text Pane / Synchronized Unit Pane ---
### --- Dragable Grid view ---
### --- BREAD CRUMB BAR ---
### --- MENU BAR ---
### --- TP - DETAILS PANE ---
Uses text pane with programmed meta data adding font/color markup to the printed Unit (containing details)
### --- TP - Palette ---
--- Drag/Drop, Grammar-Based, Template instantiatior ---
PALETTE -- list of drag-dropable template schemas
DETAILS -- details pane showing lots about current cursor location
### --- TP - Status Line ---
# ### IMPL LOG ###
## === 2021.09.29 - Browser-based programmable info view ===

- MULTI-SOURCE: Google, Dropbox, Localfiles, Github
- MULTI-FORMAT: Text(Programmed Markdown), Doc(Google, Micrsoft), Sheets(Google, excel), SQL
					Evernote, Asana, Trello, Jira
- WYSIWYG scripted compute
- LIVE / INCREMENTAL / CACHED: derived data



DETAILS 
- COMPUTE GRAPH:
	- SELECT: filter executed by on row-by-row basis w/o any other inputs (except its fixed params)
	- JOIN: Makes info from two or more tables accessible.  (and maybe SQL-joins them)
	- DERIVE: Adds derived columns based on existing table columns
	- TRANSFORM: Computes a new table as an ordered map
- NAMING:
	- Transforming and deriving is added by just appending name of the op.
	- Select and join are simply numbered.  They link to an Op expression with args
- INCREMENTAL COMPUTE & CACHING
	- DELTA - 
	- Cache maintains a set of cached values for named tables w/ specified selection of rows and cols
		Selected cols and rows by enumeration, and rows also by range selection(s)
- GUI ELEMENTS:
	- STRUCTURE = Row / Column / List / Tree
	- Text
	- Button / Menu
- WYSIWYG
	- STRUCTURE - GUI based structure manipulation
	- SELECT - GUI-based dynamic selection
	- PROPERTY BOXES - GUI-based update of property boxes (with variable or expression insertion)
	- VARIABLES - added to interface w/ control (and maybe a derivation expression)


## === 2021.03.16 - Text only
### _
- REPO/FOLDER BASED -- Uf+Python code stored in folder defines system behavior
- LIVE -- 

_
## --- 2021.01.26 - Implement a quick starter system ---
- LEXSPACE -- map: text files and at least URLS into a single lexspace
- PREFIX TREES -- implement menu-ing and merging
- URL LAUNCHER -- Browser, 
## --- 2020.12.22 - Pieces ---
- UNICORE & PYBRIDGE
- 
## --- Quick sketch - 2020.12.17 ---

EXAMPLES

RULES
a: under(foo.bar) && head<_.scope.root && has(ITEMSPEC)
a= is(a.kind) && under(some.root) && has(key=='yo' && value==$b)
	some.root

PLACE
with	some.address <- expr(x, y, z)


STEPS
1. compile rules into place history monitors
2. push updates thru rete net
3. update list of live bindings

PLACE
history
with
DerivedSpace

RETE
Rete(roots:, rules:)
root = Place		// places to watch
antecedent			// list of key/precondition mappings
precondition		// Expression with is, under, and has
predicate			// any function of place
action				// a fn of n keys including the special key 'active'
					// will trigger on and off once for each unique bind set

LIVE -- BIPUTATION
MATH
	history			// Patch
TEXT
	Regex			// TextPartition; TextSparseMatches
MARKDOWN
	md.SectionsTree(prefix)
	md.Table
	

Mount Files	-- Tree[File]
Map(contents) -- Tree		// Will have Text or Code or File entries
	
Mount Gdrive URL 				// Will have Text or Spreadsheet entries

Mount Map(Text, @live)
Mount Map(Code, @live)

MD.tree(text) --> Tree(Text)		// Contained intervals of text

TreeRuleEngine
Rule
	regex applied to Text of place

// Idea: when a rule is satisfied, then a "with" bindings to the place is made
//		 when it is not satified, then that binding is removed, and replaced
//		 with the content from before (or the shadowed content)

WithAction
//  Rule trigger satisfaction is tied to specific with application
	So it is stateless



Alias
AliasPatch		// A Patch of source/destination aliases
AliasSpace		// All entries are an aliased from somewhere according
					to its AliasPatch
					'update'

// Idea: view object should be modifiable, and mods go back to the logical place

### --- Impl Ideas ---
- DEPENDENT DATA --
- VERSIONED STORE -- Mapping to flat files.  defines model derived from text
- 
- FRAME TREE MAPPER -- 
	- TREE MAPPER -- Maps text into nested tree
	- FRAME MAPPER -- Maps frames into units (identifying frame & frame bounds)
## --- design ---
### [TEXT CLASSES]
### TREESHEET PARSER
	- build(spec) -- Returns a parser given a spec of that parser
	- parse(text, start, end) -- Returns
### INTERVAL
	- A region within the text being parsed.  (starting/ending idx)
	- A type path string (associates with a text language)
	- List of child intervals
### NODE-TYPE
	- SUB-LANGUAGE defining specialized parse rules for an interval
	- RULES a list of interval parsing rules
### HOOK
	- PATTERN -- a hook is a parameterized pattern
	- NAME -- the name of this hook
	- REGEX -- the hook pattern can be any regex
	- ARGS -- list of arg string names for groups within the regex
	- DEPTH -- name of the arg that determines depth

	Operators:
	- findall -- returns list of match dicts
	- format -- returns print form 

	- MATCHER -- a thing that matches parts 
	- get_matches
	- REGEX -- A Regex with named groupings
	- SUBNAMES - list of naming strings for the sub-intervals 4 hook
	- The first N parts are the names for the REGEX groups.
	- IMPLIED PARTS
	- EOL -- Interval from end of hook to end of line
	- INDENT -- Interval from hook upto last sub-indented line

	class Hook
	regex()		# Returns the matching regex
	depth()		# Returns depth of this hook
	name()
	findall()
	format()
### RULE
	- ANTECEDENT --  
	_
#### METHODS
### TREE
	- A hook that defines a node within a tree structure
	- DEPTH - the len or value as string of digits for a hook part
### POINTER
	- A hook that indicates a reference to some other address
### ADDRESS
### RULE
	- Specification of how to parse intervals based on hook seen
	- CONDITION
	- HOOK -- 
	- ACTIONS
	- APPEND -- adds
### matching-algorithm

	match_region(start, end, rules)

	-- findall matches for all rule regex
	-- sort them
	-- run rules in order


	hook
	_
# ### LOG ###
### --- EXAMPLES ---
#### Example hook

	hook("---{title}\n)
#### Examples in Python

	hook()
	/(-|+|*) / ==>

	/$(#*) / depth ==> fn 

	def append_list_item()

	"""

	/---{title}\n{child}.../
#### Key Ideas
##### TEXTUAL TREESHEET
	A functionally specified, bidirectional mapping from text onto structure.
	_
#### --- Examples in Uniform ---


	Hooks:

	short form:  Hook("(-|+|*) ", "bullet")
	def ListItem = Hook("(-|+|*) ", parts=[bullet])
	{"ListItem", 
	["!hook", "(-|+|*) ", ":parts", ["!list", "'bullet"])]}

> >Hook ListItem (bullet)

	ListBody = Lang()
	ListItem = Hook("(-|+|*) ", [bullet])


	def lang ListBody:
	ListItem ==> append(eol)

	if hook(")

	def text_grammar:

	item_list:
		format: "---{title}\n{}..."
### --- aim2 ---
Aim: Present underlying text in all the right ways for task of the moment
_
### --- 2020.12.18 - INTRO ---

**KNOWLEDGE MANAGEMENT** -- The purpose of _**knowledge management (KM)**_ is to _PRESENT_ the most relevant information, organized and visualized in the best ways to enable the understanding and reasoning required for action.

==> NOTICE:  100% of the value provided by KM flows through GOAL APPROPRIATE PRESENTATION of information.  (Organizing info, or storing info, is not the aim of KM, rather those are secondary considerations, what is primary is how the pixels of the user's monitor are used to present info required for understanding and action -- it is all about showing right stuff at right time in the right way.)

==> THEREFORE:  An ideal KM tool would be a WYSIWYG interface with unlimited FLEXIBILITY used to overcome PERCEPTION CONSTRAINTS of some knowldege-based task
- FLEXIBILITY -- An ideal KM tool should allow any computable selection of data to be presented, applying any computable re-org of that info.
- PERCEPTION CONSTRAINTS -- Human perception and I/O devices both impose significant restrictions on info transfer, thus an ideal KM tool would allow maximum flexibility in presenting in the best way to overcome perception constraints.
- WYSIWYG -- The space of possible re-organizations and presentations of some underlying knowelge far more complex than the underlying knowlege itself.  Thus an ideal KM tool must support the meta KM decision-action of configuring the tool itself.  One powerful and intuitive method is WYSIWYG controls the expose the space of transformations & presentations as sequences of step-wise live WYSIWGY control actions.  The user navigates the meta space, by applying a sequence of step-wise data/presentation manipuations to achieve a data view ideal for the current KM task.
(We call reuse of these manipulation steps as WYSIWYG PROGRAMMING)



DECISIONS REPEAT -- 

- **K PRESENTATION NOT K MANAGEMENT** -- We rejected the model of KM where the _management_ of knowledge is primary, instead _presentation_ is primary.

- **PRESENTATIONS REPEAT** -- Still in many cases the kinds of observe-orient-decide-act loops required will fit into a regular pattern / organization.

- MANY EXCEPTIONS TO THIS REPEATING -- But the regularity of best presentation has more exceptions than rules.  Rigid presentation/organzations will need to be tweaked in an never-ending long-tail of special one off cases.

- EVOLVED NOT DEFINED -- Best orgnaizations and presentations are generally not know apriori, but are evolved and understood a posterori.


THEREFORE:

- LIVE -- An ideal KM tool would be live, showing all views as if the user reapplied all WYSIWYG operations to the new data as the underlying data changes.

- PORTABLE -- Because these decision patterns repeat in complex ways, a user should be able to apply earlier meta KM configuration work to new data in new places, with WYSIWYG interactive resolution of the deltas required to make the decision pattern work well over the new data.

- EVOLVING -- Because ideal organzations and presentations are only understood post-hoc, the ideal tool supports knowlege capture into no, or incorrect organzations, and adding changing organization afterwards.

- PARTIAL -- Because K management is not primary, even when a better organzation is understood, the work of applying that orgnazation to existing infomation is only performed upto the point required for the current PRESENTATION task.  Later presentation tasks may require more knowlege to be converted, or a yet new organzation to be applied.  
==> PRESENTATION not MANAGEMENT is primary.  
Thus the knoweldge will always be a state of partial transform where different subsets of a single knowlege type will be encoded according to a branching graph of conventions and constraints.  Like a worker that only cleans the immediate area around where they are working, these knowlege workers never "clean up" more than is require for the current K task, since they know that in the future there likely will be a new-new orgnaization and that effort have been in vain.  Still these workers to CLEAN the data as they use it.  It is a kind of on-going KM "code-debt" reduction effort that ensures that K debt-reductions are propagated forward to future K tasks get the benefit of the debt-reduction performed.

_
						
