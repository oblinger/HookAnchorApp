
# ### VOCABULARY ###
SPACE -- A set with some structure (operator) defined over it.
## === AGENDA ===
### --- UNIFORM ECOSYSTEM ---

**UNIFORM ECOSYSTEM** -- The universe of interrelated frameworks, agendas, langauges, interfaces, applications, and data stores developed from and around Unicore.

**UNIFORM AGENDA** -- The interoperability agenda aimed at simplifying and unifying human knowledge work.

**UNICORE** -- The 7 Structural and 7 Functional "Ur" constructs out of which the entire uniform ecosystem is constructed.

**UNIFORM STRUCTURE** -- Some CONTENT within the data graph -- a set of triples.

**UNIFORM FUNCTION** -- Some MEANING of the data graph -- the process or results of interpreting that data.  (Interpretation that may be applied to the graph.)

**UNIFORM LANGUAGE**-- 

**UNIFORM MENAGERIE** -- 

**UNIFORM COLLABORATION** -- 

**UNIFORM MARKETPLACE** -- 

**UNIFORM SOCIETY** -- 
### --- UNIFORM AGENDA ---

**UNIFORM AGENDA** -- The goal and process for creating a best possible language-writing-language (meta-programming language).

**META-PROGRAMMING** -- Programs that manipulate the fine-grained structure (individual instructions) of other programs as a data structure.

**VIRTUE** -- A measurable factor which encodes some aspect of a notion of quality, goodness, or fit.

**LANGUAGE VIRTUE** -- A factor in assessing "best possible" language-writing-language.

**INDEPENDENT** -- 

**INTEROPERABLE** -- 

**ESSENTIAL** -- 

**SHARP** -- 

**SINGULAR/UNFORKED** -- 

**UNIFORM** -- 

**EMBEDDABLE** -- 

**SPROUTY** -- 

**NATURAL** -- 

**SUGARED** -- 

**COMPLETE** -- 

**PRACTICAL** -- 

**PERFORMANT** -- 

**LIVE** -- 

**HOMOICONIC/META-PROGRAMMABLE** -- 

**SHIMLESS** -- 

**COVER** -- 

**DECOMPLECT** -- 

**OBLITERATE** -- 

**CAPTURE** -- 
## === STRUCTURAL CONSTRUCTS ===
### --- DATA GRAPH ---

**DATA GRAPH** -- Construct.  A graph of nodes with node-labelled, directed edges.

**UNIT** -- Type.  A unit is a node within the data graph.

**ATOM** -- Type. A unit with predefined associations.  (For Uniform atomic units associate to JSON numbers or JSON strings.)

**TRIPLE** -- Type.  An edge within the data graph, expressed as three units: the subject, the index, and the value.

**SUBJECT** -- Noun.  The first component of a triple.  This unit is the source of the labelled-edge.  (Also simply called the 'unit'.)

**KEY** -- Noun.  The second component of a triple.  This unit serves as label on the edge.  (Also called the 'predicate' of the triple.)

**VALUE** -- Noun.  The third component of a triple.  This unit is the destination of the labelled-edge.  (Also called the 'object' of the triple.)
### --- PRIMAL PATTERNS ---

**PRIMAL PATTERN** -- Construct.  The four data structures that underly unicore:  Iterable, Bag, List, and Tree.

**DATA STRUCTURE** -- Noun.  A structure within the data that follows a specfic pattern. (??? restrict to pattern, or just any subset???)

**COLLECTION** -- Type.  The possibly infinite set of units accessible from some root unit via a single edge traversal in the data graph.  NOTE: Parts or all of a collection may not be accessible via its backing operators.

**ITERABLE** -- Type.  A possibly infinite Collection whose ITR operatoe is define -- that is a collection that can be iterated.
NOTE: The ordering generated by the iterator may or may not be stable.

**BAG** -- Type.  An Iterable that is GET-able and ITR-ateable, but may not be SET-able, and may not have a stable ITR ordering.

**LIST** -- Type.  A possibly infinite bag with a fully defined ordering over its elements as encoded by its stable ITR operator.

**TREE** -- A singly connected sub-graph in the data.  
(OTHER DEFINITION???  This def is not quite right.  Must not traverse up from root, and must only traverse specified keys)  

**UP???** -- 

**KEY??? INDEX??? / PREDICATE???** --   

**CHILD** -- 

**PARENT** -- 

**ANCESTOR** -- 

**DESCENDENT** --  
### --- BACKING TERMS ---

**BACKING** -- Contruct.  The nine operators that define and provide access to a unit's structure within in the data graph.

**STRUCTURE FOR A UNIT** -- Noun.  The structure for a given unit, U, is the set of all triples having that unit as their subject (first component).

**???CONTROL UNIT** -- The unit returned by the FNS operator, and is used to access the backing operators underlying a unit, or the unit's immediate children.

**GET** -- 
**SET** -- 
**NEW** -- 
**DEL** -- 
**LEN** -- 
**ITR** -- 
**IDX** -- 
**UP** -- 
**FNS** -- 
### --- ADDRESSING ---

**ADDRESSING** -- Construct.  The types and operators related to addresses.

**ADDRESS** -- A structure, S, is said to be an address for unit, U, within some other targeted structure, T, if there is a parallel 
between the structure of S and T which can be exploited by some fixed addressing procedure, P, to derive the targeted unit U, 
from given ONLY the address, S, and targeted structure T.  (Informally, an address is any data that can serve traverse some targeted data structure without use of any additional indexing data.  So a file path is an address for a filesystem, and an integer is an address for processor memory, but a logical name is NOT an address for its target, since one needs to have a lookup table for the logical name.)

**PATH** -- Type.  The List of indicies that may be passed to the GET operator in order to traverse from some source unit to some 
targeted unit within the data graph.  A type of address for unit's within the data graph.

**ORIGIN** -- Noun.  The unit that serves as the implicit source for the path operators.

**PATCH** -- Noun.  

**PATH_TOP** -- Operator.  
**PATH** -- Operator.  Returns the structural path to a unit from some origin unit (which need not be the top unit)
**PATH_GET** -- 
**PATH_SET** -- 
**PATH_GETS** -- 
**PATH_SETS** -- 
??? path_compare 
??? dual
### --- UNIT-FORM ---

**UNIT FORM** -- Construct.  A simple bi-directional mapping from bounded, tree units and text strings.

**HEAD** -- The unit value associated with the special "__" (two underscore) meta key.

**IDENTITY** -- indicates that two units are in fact the same unit, e.g. u === v indicates that u and v are the same unit in the data graph.

**EQUALITY** -- indicates that two units have the same print string, e.g. u == v indicates that print(u) returns the same string value as print(v).

**RECOVERABLE IDENTITY** -- a unit has recoverable identity if it print-parses to the identical unit.  i.e. u === parse( print( u ) )

**RECOVERABLE EQUALITY** -- a unit has recoverable equality if it print-parses to an equivelant unit.  i.e. u == parse( print( u ) )

**BOUNDED UNIT** -- a unit is bounded if it has defined, finite LEN, and all of its children are bounded.

**SYMBOL UNIT** -- an atom equivelant to its own head.

**KEYWORD UNIT** -- an identity-recoverable symbol.

**FIXED** -- Adj.  Used to indicate triples associated a subject unit where the key is a natural-number less than the LEN of the subject.  (Also used to refer to just the key or the just value of such a triple.)

**META** -- Adj.  Used to indicate triples associated a subject unit where the key is a  a valid program identifier string beginning and ending with "__" (two underscore characters.)  A valid program identifier is some combination of underscores, alpha, and digit characters.  (Meta is also used to refer to just the key or the just value of such a triple.)

**NAMED** -- Adj.  Used to indicate triples associated a subject unit where the key is a valid program identifier string that is NOT a meta key.

**ARG** -- Adj.  A fixed or named triple, or the key/value of such a triple.
### --- UNIFORM SOURCE-CODE PARSING ---

**UNIFORM SOURCE-CODE STRUCTURE** -- Construct.  A generalized code and data format which is flexible enough to accomodate most all 
formalized textual forms used in modern software.  (??? Maybe just part of code-markdown construct ???)

**SOURCE GROUPING** -- A delimited interval of source-code text, which may contain other source groupings, and may contain 
a sequence of statements.

**SOURCE STATEMENT** -- A toplevel interval of text with in a grouping which are indicated by an initiator token, or separated by separator tokens.  Statements may not contain other statements, but may contain expressions.

**SOURCE EXPRESSION** -- An interval of text contained within statements, and that may contain other sub-expressions.  Expressions are separated by separator tokens, and may be indicated by a prefix, infix, or suffix punctuation tokens.

**SOURCE INTERVAL** -- An interval of characters within the source text string.  The source text string is partitioned into a sequence of whitespace, punctuation, literal, and unparsed token regions.

**TOKEN PRECEDENCE** -- Noun.  A partial ordering defined over language punctuation tokens.  This ordering determines the nesting structure of intervals indicated by these tokens.

**PREFIX / INFIX / SUFFIX INTERVALS** -- By default all tokens form infix operators over the operators associated with higher precedent intervals to their left and right.  Gaps in this infix tree of operators caused by adjacent intervals with lower precedent are filled with the special GAP token.

**SOURCE COMMENT** -- 
### --- EXPECTED OPERATORS ---

**EXPECTED OPERATORS** -- Construct.  The operators upon which the Unicore is a layer depends.  NOTE:  Unicore is defined in a way that it can fit naturally into a wide range of interpretational contexts.  Theaw operators are assumed to be defined by this host context, and the precise semantics of these operators is thus defined by the host context.

**EXPECTED ATOMIC OPERATORS** -- Expected operators that apply and return atomic units.

**EXPECTED COLLECTION OPERATORS** -- Expected operators that accept at least one collection unit.

**THE "+" OPERATOR** -- This unicore collection operator is specially designed to combine list-like and map-like behaviors in a specific required to support a great many unforkings in construct combinations.  This operator nontheless operates as expected on plan sets, multi-sets, lists, maps, ordered-maps, etc.

#### ... LISTY OPS ...
get
len
first
append
clear
contains
delete
extend
find
index_of
pop
slice
set_slice
update
push
reverse

#### ... Symbols ...

false<br>
gap<br>
inf<br>
minus_inf<br>
nan<br>
null<br>
true<br>
und<br>
<br><br>
## === FUNCTIONAL CONSTRUCTS ===
### --- UNIFORM INTERPRETATION ---

**INTERPRETATION** -- Construct.  The process of applying the &alpha;-interpretation rewrite system to some data form.

**ENV** -- Type.  

**^ALPHA** -- Meta Key.  

**SELF** -- 

**EVAL** -- Operator.  The default form of interpretation &mdash; indicates the interpratational process executing, or 
deriving a return value for a form.

**NORMALIZE** -- Operator.  
### --- UNICORE CONTROL FLOW ---

BLK
BRA
CHN
REP
RET
### --- UNIFORM LANGUAGE MODEL ---

**UNIFORM LANGUAGE MODEL** -- Construct.  A simplest framework for encoding a meta-programming language.

**FORM** -- Noun.  Data of some type (String, Code, Lib, Env, etc.) that implicilty or explicitly is able to be translated into an alpha-interpretable structure. 

**IN THE META-PROGRAMMING CONTEXT THE DIVIDING BOUNDARY IS A BIT BLURRY** -- but the idea is if data can be understood as a kind of interpretable source code we call it a form, if it represents parametric data to be accepted as input by soem other program, then we called it data.

**LANG API** -- Interface.  The operators and types that support operations over a generic meta-programming language.

**PARSE** -- Operator.  

**PRINT** -- Operator.  

**DUMP** -- Operator. 

**LOAD** -- Operator.  

**BANG** -- Operator.  

**STR** -- Type.  
**CODE** -- Type.  
**LIB** -- Type.  
## === LANGUAGE CONSTRUCTS ===
### --- UNIFORM SUGAR ---

**TRANSFORM** -- Type.  Operator that uses args to qualify how 'self' unit is transformed.  (Any operator that leverages the self unit and returns some unit can be viewed as a transform operator.)

**ENGINE** -- 
### --- UNIFORM OPTIONS ---

**OPTION** -- Construct.    A parameter indicating some intrinsic aspect of the interpretational nature of a unit form.
### --- UNIFORM TYPE ---

**TYPE** -- Construct.  A constraint on the structure of the function of a unit.  

**THIS CONSTRAINT IMPLICITLY DEFINES A SET** -- those units that satisfy the constraint.  

OPTIONALLY EXPRESSED VIA A: 
1. **'DUCK' TYPING** -- an operators that whose return value is SAT when its input is a member of the type's set, 
2. **'intrinsic' typing** -- an invarient associated with a unit at creation which guarantees the unit satifies the constraints of the type, 
3. **type 'name'** -- a semantics address (dotted name) which is associated with a type, and which may be associated with a unit.  (Unlike the other forms of typing, it is possible that a unit is associated with a type, but does not fully live up to the constraints implied by that type.)

What you say you are, what others have verified you currently are, what is your intrinsic nature.
## === MISC ===
### --- Computational time interval names ---
**PARSE TIME** -- 

**LOAD TIME** -- Computation occurring after unit forms have been parsed from their source
textual or graphical forms and before being assigned into Lexspace.
Normalizing &alpha;-interpretations are the only computations performed at this time.<br>

**RUN TIME** -- Computation occurring after caching time are all considered primary or run time
computations.  These include eval, assign, and meta &alpha;-interpretations.<br>
<br><br>

-- this is just load time ---
**COMPILE TIME** -- Computations occurring after Lexspace forms are loaded and before                <!-- better term? -->
primary computation is performed over these structures.  Cache time computation includes
macro expansion &alpha;-interpretations as well as <q><i>live data</i></q> caching computations.
(note compilation is simply one of many forms of caching/expansions derived from the Lexspace forms.)<br>
### --- Meta descriptors ---
astronautics<br>
-tastic<br>
pythonic<br>
# REST
aaa
<H1>OLDER VOCABULARY ITEMS</H1>
aa
<br><br>


=== Primative Datatype ===<br>
INT<br>
LST<br>
NUM<br>
OBJ<br>
STR<br>
???SYM<br>
=== Datatypes ===<br>
bool<br>
atom ???atomic<br>
composite<br>
<br><br>

=== Uniform Structure ===<br>

=== Uniform Control ===<br>
=== Control Flow ===<br>
and<br>
block<br>
break<br>
chain<br>
continue<br>
if / elif / else<br>
for<br>
switch / case<br>
try / catch<br>
<br><br><br>




=== Selector ===<br>
all<br>
any<br>

=== Uniform Declaration ===<br>
CTX<br>
???OP<br>
PKG<br>
VAR<br>
=== Uniform Declarations ===<br>
class<br>
list<br>
<br><br>

=== Programming Model Primatives ===<br>
exe <br>
=== Uniform Programming Model ===<br>
bang<br>
???alpha
code<br>
data<br>
env<br>
eval<br>
interp<br>
lang<br>
load<br>
?dump<br>
<br><br>


=== Super U ===<br>
immutable
lazy
eager
history

=== Engines ===<br>
engine
resolve rewrite

=== Maybe Terms ===<br>
constructs, declaration, default<br>
size slice rest find pop update
alias import
<hr><hr><hr><br><br><br>


address
alt
args
assign

???base
**DEFXXX** -- defop defclass defspec

select


form format  index   key  last lex lexical  live   lst macro map match meta
method name native  none not null  path pkg prefix print provide ret  root sat scope self
semantic  space spec static subunits sym time title top tree true try type uniform unit universe
value var view when with

compile contents copy declarative  dependent docs dot  equals
error float gnd graph homoiconic  next normalize
path_get path_follow  path_list path_set path_sets
remove  require
version


seed close delete gui inverse -ish  main max nan opts patch permissions persist persistent
template union

nputative nth set_head sort spiral url


**AT** -- Keyword.  Specifier of placement in either time or space.<br>
**BACKING** -- Noun.  The unit used to implement the semantics, values, and behavior for some sub-lexspace.<br>
**BINDINGS** -- Noun.  <br>
**CODE** -- Noun.  A constant unit with finite size whose subunits are all also Code.
Code is intended as units to be assigned into Lexspace for subsequent semantic interpretation.<br>

**DEFS** -- Noun.  <br>

**FORM** -- Adj.  Modifier on Text, Data, and Definitions indicating that the instance is intended to provide meaning.<br>
**IS** -- <br>
**KEYWORD** -- Noun. A Unit representing the index of one Unit within the <q>structure</q> of an a <q>containing</q> Unit.<br>
		Sometimes keywords are restricted to be a non-negative integer or symbol value.
		(See <i>qualifier</i> to understand keywords on forms.)<br>
**LEX** -- Noun.<br>
**PATH** -- Noun.<br>
**QUALIFIER** -- Noun.  A <i>qualifier</i> is data that somehow affects <i>behavior</i>.  Lexical <code>Options</code>, and
		Operator <i>keyword</i>s two kinds of behavior qualifiers.<br>
**???REF???** -- <br>
**SPACE** -- Noun.  The unbounded structure of Lex places.<br>
**TIME** -- Noun.  The unbounded, ordered sequence of interpretation steps (EXE operator applications) following
		'bang'.<br>
**???TYPE** -- <br>
**UNIT** -- Noun.<br>
**VALUE** -- Noun. A Unit representing in input or output of an assignment, or the result of a computation.<br>
**VAR** -- Noun.  Placeholder structure.<br>


=== UNSORTED ===<br>

**CONCEPTUALIZATION** -- A thing that can naturally be understood by people as a standalone thing with its own interpretive meaning.  Conceptualizations may be expressed by a combination of simply naming it, in the case that it is generally understood by people, by providing a natural language definition (e.g. in English), or formal specifiation might be used for part or all of the conceptualization.<br><br>

**CONSTRUCT** -- Uniform conceptualizations with provided reference implementations and natural language documentation, and unique naming.<br><br>

**REALIZATION** -- An implemention (code) that matches some an implicitly or explicitly expressed conceptualization.<br><br>



alpha   means means root thing supporting everything.  thing that is its own cause, thing that is its own parent.
str     means bridge from text (sequence of characters) to Unit (tree of unit)


in      means set the 'self' object being passed 'in' to an operator
out     means set the 'self' object which will be return 'out' of an operator
key     means the 'key' used in this unit's 'home' context to index this unit
parent  means up to the 'home' context for this unit
ret     means return
# Rest of HTML

<!DOCTYPE html>
**<!--SUPPRESS ALL** -->
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <!-- link rel="stylesheet" type="text/css" href="stylesheets/bootstrap-theme.min.css" media="screen" -->
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css.unused" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Uniform Vocabulary</title>
</head>

<body>

<div id="container" class="inner">
    <header><h1><centerit>UNIFORM VOCABULARY</centerit></h1></header>

    <h1>Vocabulary</h1>
<p>



    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <h3>Introduction</h3>
    <p> In order to maintain parsimony and orthogonality across the entire Uniform language, all vocabulary terms
        (symbols) are understood intuitively as part of a single flat set of <i>conceptual <q>UR</q> building blocks</i>.
        We avoid using the <i>same</i> term in different <i>unrelated</i> ways in different parts of Uniform.
        Conversely we also avoid using <i>different</i> terms for cases where a programmer might productively imagine
        operations as being intuitively <i>related</i> to underlying some <q>UR concept.</q></p>

    <p> So in Uniform identifier choice matters a great deal.  It has both informal implications of relatedness,
        and formal / computational consequences that connect underlying behaviors.  Kinds of terms:</p>

    <ul>
        <li><d>abbreviations</d> &mdash; terms use so frequently within Uniform, that they are provided
            specific abbreviation common throughout the documentation.</li>
        <li><d>uniform nouns</d> &mdash; terms that correspond types of Unit in Uniform, the reification of some
            abstract notion (like <i>load time</i>), or a term that refers to something in the physical world
            beyond Uniform (like <i>user</i>).</li>
        <li><d>uniform verbs</d> &mdash; unit operators expressing <q>actions</q> applied to underlying unit.
            The time required for operation rather than its result is the focus of a verb operator.</li>
        <li><d>uniform adjectives</d> &mdash; unit operators expressing an <q>accessor</q> over its underlying unit.
            The result of the operator application rather than the time require for the computation is the focus
            for an adjective operator.  Result stability is expected from an adjective operator.  The returned value
            should only change when the <q>state</q> of underlying unit has changed.</li>
        <li><d>uniform adverbs</d> &mdash; keyword modifiers for verb/adjective unit operators.</li>
        <li><d>meta descriptors</d> &mdash; terms used to formally or informally discuss aspects of
            software or language systems.</li>
    </ul>


    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <h3>Adjeteival Reifiers</h3>

    !!! Should this exist and be included ???

    <p> As a language writing language, Uniform is in the business of creating new constructs.
        Central to Uniform thinking is the idea that important things should be concise things.
        Thus it is natural, that on occasion this would involve even the creation of new words which don't exist
        in any natural or formal language.  Usually the value of these words is that they are visibly related to
        a word which does already exist, thus the reader already has some idea as to the meaning of the new word.
        Here we include a few modifiers that fit common patterns of new word need.  These suffixes modify
        the meaning of the underlying word in a somewhat predicable way, and the resulting word itself is
        typically an adjective used to indicate some quality in the constructs and data of a new DSL.</p>

    <dl>
        <dt><d><large>-ish</large></d></dt>
        <dd><q>-ish</q> is used when the underlying adjective correctly indicates the intent and spirit, but
            at some technical level is not fully accurate.  For example a <q>const-ish</q> variable it
            treated and thought of as a constant value.  But describing it as a constant would be incorrect and
            misleading, since there are important ways and scopes where that value varys &mdash; it is const-ish.</dd>

        <dt><large><d>-ic</d></large></dt>

        <dt><large><d>-tastic</d></large></dt>
    </dl>



    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <h3>Uniform Abbreviations</h3>

    <table>
        <!--tr><th colspan="3"><code><d>Abbreviation with associated meaning</d></code></th></tr-->

        <!--tr><td><code><d></d></code></td>
            <td><code></code> &mdash; </td></tr-->

        <tr><td width="5%"><code><d>f</d></code></td>   <td width="10%"><d>Form</d></td>
            <td>A <code>Unit</code> understood to convey semantics, as instructions to execute, or
                as lexical structure to define semantic <code>Bindings</code>.</td></tr>

        <tr><td><code><d>i</d></code></td>   <td><d>Int</d></td>
            <td>Integer value.</td></tr>

        <tr><td><code><d>k</d></code></td>   <td><d>Key</d></td>
            <td>A <q>key</q> (keyword) is index of one Unit within the <q>structure</q> of an a <q>containing</q> Unit.</td></tr>

        <tr><td><code><d>n</d></code></td>   <td><d>Num</d></td>
            <td>Numeric value (either floating point or integer).</td></tr>

        <tr><td><code><d>s</d></code></td>   <td><d>Str</d></td>
            <td>String variable value.</td></tr>

        <tr><td><code><d>u</d></code></td>   <td><d>Unit</d></td>
            <td>Unit variable value.</td></tr>

        <tr><td><code><d>v</d></code></td>   <td><d>Value</d></td>
            <td>A Unit that is an
                input or output of an assignment, or result of a computation. </td></tr>


        <tr><td><br><d></d></td>    <td><d></d></td>    <td></td></tr>
        <tr><td><code><d>ts</d></code></td>   <td><code><d>Typespec</d></code></td>
            <td>????</td></tr>




        <tr><td><d>---</d></td>    <td><d>------------</d></td>
            <td>------------------------</td></tr>

        <tr><td><d>alt</d></td>    <td><d>alternate</d></td>
            <td>The specification of the action to take as an <q>alternate</q> to the expected execution path</td></tr>

        <tr><td><d>Bnd?</d></td>    <td><d>Bindings</d></td>
            <td></td></tr>

        <tr><td><d></d></td>    <td><d></d></td>
            <td></td></tr>

        <tr><td><d></d></td>    <td><d></d></td>
            <td></td></tr>

        <tr><td><d>doc</d></td>    <td><d>documentation</d></td>
            <td></td></tr>

        <tr><td><d>opt</d></td>    <td><d>option</d></td>
            <td>An <q>option</q> is the specification of a change from some standard behavior or meaning.</td></tr>

        <tr><td><d></d></td>    <td><d></d></td>
            <td></td></tr>

        <tr><td><d>req</d></td>    <td>require</td>   <!-- NO? -->
            <td>The <q>require</q> form is replaced by a matching unit at load time</td></tr>

        <tr><td><d>sym</d></td>   <td>Symbol</td>
            <td>Symbol variable value.</td></tr>

        <tr><td><d></d></td>    <td><d></d></td>
            <td></td></tr>

        <tr><td><d>uf</d></td>    <td><d>uniform</d></td>
            <td>The <code>uf</code> package refers in some way to the Uniform langauge.</td></tr>

        <tr><td><d></d></td>    <td><d></d></td>
            <td></td></tr>

    </table>
    <br><br>



    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->

    <h3>Central QUALIFIERS in Uniform</h3>

    <var><d>alpha</d> &mdash; alpha indicates the <q>beginning</q> or underpinnings of a thing.  In Uniform, the
        <code>alpha.*</code> binding subspace contains all information underlying the current interpretation
        environment.  Alpha also refers the <v>&alpha;</v> in <v>&alpha;</v>-interpretation, the interpretation
        paradigm which underlies all Uniform computation and all semantics.</var>


    <var><d>static</d> &mdash; being derived from the unchanging structure of things.</var>
    <var><d>dynamic</d> &mdash; being derived from the varying process of interpretation / execution.</var>


    <var><d>structural</d> &mdash; refers to operators that operate directly using only data accessors.</var>
    <var><d>lexical</d> &mdash; .</var>
    <var><d>semantic</d> &mdash; .</var>
    <var><d>functional</d> &mdash; .</var>

    <var><d>spiral</d> &mdash; an sequence of expanded structures in which each subsequent element contains the
        virtues and actuality of all previous elements in the sequence.  Spiral Docs, Spiral Specs, Spiral development.</var>

    <h3>Central NOUNS in Uniform</h3>

    <var><d>binding</d> &mdash; .</var>


    <h3>Central VERBS (operators) in Uniform</h3>

    <var><d>linking</d> &mdash; fusing of multiple semantic structures into a single structure whose semantics are based on,
        that preserve, and somehow fuse the semantics of the constituent parts.</var>

    <var><d>compiling</d> &mdash; .</var>

    <var><d>data</d> &mdash; .</var>
    <var><d></d> &mdash; .</var>
    <var><d></d> &mdash; .</var>
    <var><d></d> &mdash; .</var>




    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->





    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <h3>Uniform Verbs</h3>
    <b> A <d>verb</d> is an operator whose intent is focused on the <i>CHANGE</i> that they make either to the
        unit to which they are applied (e.g. delete), or to the larger Lexspace universe (e.g. load), or are focused
        on a process occurring over a span of time which that operator triggers (e.g. bang).</b>

    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <h3>Uniform Adjectives </h3>
    <p> <b>Unit <q>accessor</q> operators &mdash; operators that return a <q>property</q> of the unit which remains
        constant as long as the underlying unit itself remains unchanged.</b></p>

    <h4>Unicore defining structural accessors</h4>
    <p> These operators provide access to a Unit's <i>structure</i>.  The first four <code>get set itr len</code>
        define the unit's structure.  The remaining structural accessors are defined in terms of these first four
        primary accessors.</p>

    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <h3>Uniform Adverbs &mdash; keyword modifiers for verb/adjective operators</h3>
    Thus this list of qualifiers represents the full set of distinct <q>aspects</q> understood in the Uniform language.
    <dl>
        <dt><code><d>:</d> <i></i></code></dt>
        <dd>.</dd>

        <dt><code><d>:</d> <i></i></code></dt>
        <dd>.</dd>

        <dt><code><d>default:</d></code></dt>
        <dd>Specifies a value to be used in lieu of or prior to any explicitly provided or computed value.</dd>

        <dt><code><d>in:</d> <i></i></code></dt>
        <dd>.</dd>

        <dt><code><d>__lex__:</d> <i>lex</i></code></dt>
        <dd>Every form and every Unit specifies a "place" in Lexspace where it is <i>located</i>.  (see <code>lex:</code> as well).</dd>

        <dt><code><d>lex:</d> <i></i></code></dt>
        <dd>Specifies the Lexspace "place" on which this statement <i>operates</i>.  (see <code>__lex__</code> as well).</dd>

        <dt><code><d>max:</d></code></dt>
        <dd>Specifies a maximal (inclusive) permissible value against some implied total ordering (usually <code>Num</code>).</dd>

        <dt><code><d>min:</d></code></dt>
        <dd>Specifies a minimal (inclusive) permissible value against some implied total ordering (usually <code>Num</code>).</dd>


        <dt><code><d>out:</d> <i></i></code></dt>
        <dd>.</dd>

    </dl>




    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <!----------------------------------------------------------------------------------------------------------------->
    <h3>Uniform Meta Descriptors &mdash; terms used to describe aspects of software or language systems</h3>


    <h4>Syntactic Form Descriptors</h4>

    <dl>
        <dt><code><d>statement form</d></code></dt>
        <dd>A syntactic variant of Unit Form where the head symbol is not followed by <code>( ... )</code> but instead
            is followed by the bare unit body terminated by end of line, by <code>;</code> or by a block form <code>{ ... }</code></dd>

        <dt><code>YAMAIC form</code></dt>
        <dd>A syntactic variant of Unit Form where whitespace sensitive indention is used to indicate the body of
            the Unit in a way similar to YAML syntax.</dd>

        <dt><code>PYTHONIC form</code></dt>
        <dd>A syntactic variant of Unit Form where whitespace sensitive indention is used to indicate the code
            sub-forms in a way similar to PYTHON syntax.</dd>


        <dt><code>JSON form</code></dt>
        <dd>An embedding of Unit data as JSON lists.</dd>

        <dt><code>JAVAIC form</code></dt>
        <dd>A whitespace insensitive Unit Form variant that expresses unit data a JAVA like statements and expressions.</dd>

    </dl>


    <h4>Uniform-specific language terms</h4>


    <var><d>behavioral</d> &mdash; Pertaining to Uniform run time computation &mdash; the
        <code>eval</code>-interpretation of Unit data.</var>

    <var><d>lexical</d> &mdash; Information derived from the containment structure of Lexspace..</var>

    <var><d>Lexroot</d> &mdash; The Lex unit that defines the Lexspace used during a computation.</var>

    <var><d>Lexspace</d> &mdash; Subspace under Lexroot.</var>

    <var><d>semantics</d> &mdash; Pertaining to the <code>Bindings</code> structures used to map identifiers
        <code>ref</code>s onto their meaning forms.</var>

    <var><d>subspace</d> &mdash; Tree of Lex rooted at a single Lex node.</var>






    <footer>
        Copyright (c)  Daniel Oblinger.  All rights reserved.
    </footer>
</div>
</body>
</html>


