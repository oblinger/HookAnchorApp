#!/bin/zsh
# HookAnchor shell functions and completions
# This file contains zsh functions that integrate with HookAnchor (ha command)

# Common function to handle ha lookups with optional fzf selection
# Arguments:
#   $1: search term
#   $2: ha command flag (-f for folder, -x for execute/file)
#   $3: action (cd, echo_dir, echo_file)
_ha_lookup() {
    local search_term="$1"
    local ha_flag="$2"
    local action="$3"

    local lookup_result
    lookup_result=$(ha "$ha_flag" "$search_term" 2>/dev/null)

    if [ $? -eq 0 ] && [ -n "$lookup_result" ]; then
        local num_matches=$(echo "$lookup_result" | wc -l)

        if [ "$num_matches" -eq 1 ]; then
            # Single match - perform action directly
            case "$action" in
                cd)
                    local target_path=$(echo "$lookup_result" | sed 's/.* -> //')
                    cd "$target_path"
                    ;;
                echo_dir)
                    # For directory, extract path from folder lookup
                    echo "$lookup_result"
                    ;;
                echo_file)
                    # For file, the result is the full path
                    echo "$lookup_result"
                    ;;
            esac
        else
            # Multiple matches - use fzf for selection
            local selected
            if [ "$ha_flag" = "-F" ]; then
                # Folder format with arrow
                selected=$(echo "$lookup_result" | fzf --height 40% --reverse --preview 'ls -la {+2}' --delimiter ' -> ' --with-nth 1 --query="$search_term" -i)
                if [ -n "$selected" ]; then
                    case "$action" in
                        cd)
                            local dir=$(echo "$selected" | sed 's/.* -> //')
                            cd "$dir"
                            ;;
                        echo_dir)
                            echo "$selected" | sed 's/.* -> //'
                            ;;
                    esac
                fi
            else
                # Direct file path format
                selected=$(echo "$lookup_result" | fzf --height 40% --reverse --query="$search_term" -i)
                if [ -n "$selected" ]; then
                    echo "$selected"
                fi
            fi
        fi
    else
        echo "No match found for '$search_term'" >&2
        return 1
    fi
}

# ff function - fuzzy find and cd to directories
ff() {
    if [ $# -eq 0 ]; then
        # No arguments - use fzf to browse all folders with command names
        local selected
        selected=$(ha -F '' 2>/dev/null | fzf --height 40% --reverse --preview 'ls -la {+2}' --delimiter ' -> ' --with-nth 1 -i)
        if [ -n "$selected" ]; then
            local dir=$(echo "$selected" | sed 's/.* -> //')
            cd "$dir"
        fi
    else
        # Use common lookup function
        _ha_lookup "$*" "-F" "cd"
    fi
}

# fp function - print full file path for command
fp() {
    if [ $# -eq 0 ]; then
        echo "Usage: fp <command>" >&2
        echo "Example: cat \$(fp mycommand)" >&2
        return 1
    fi

    # First find matching command names (take first match if query is specific enough)
    local search_term="$*"
    local matches=$(ha -m "$search_term" 2>/dev/null)

    if [ -z "$matches" ]; then
        echo "No match found for '$search_term'" >&2
        return 1
    fi

    # Just take the first match for now (same behavior as ff with single match)
    local selected_cmd=$(echo "$matches" | head -1)

    # Now extract the file path from commands.txt for this command
    # Need to escape special characters in the command name for grep
    local escaped_cmd=$(echo "$selected_cmd" | sed 's/[[\.*^$()+?{|]/\\&/g')
    local cmd_line=$(grep "! *${escaped_cmd}:" ~/.config/hookanchor/commands.txt 2>/dev/null | head -1)

    if [ -n "$cmd_line" ]; then
        # Extract path after semicolon (format: category! Name:action params; path)
        local file_path=$(echo "$cmd_line" | sed 's/^[^;]*; *//')
        if [ -n "$file_path" ] && [ "$file_path" != "$cmd_line" ]; then
            echo "$file_path"
        else
            # No path in command, maybe it's a folder-based command
            # Try to get the folder for this command instead
            ha -f "$selected_cmd" 2>/dev/null
        fi
    else
        # Command not found in commands.txt, try folder lookup
        ha -f "$selected_cmd" 2>/dev/null
    fi
}

# fd function - print directory path for command
fd() {
    if [ $# -eq 0 ]; then
        echo "Usage: fd <command>" >&2
        echo "Example: ls \$(fd myproject)" >&2
        return 1
    fi

    # Use ha -f to get the directory path
    _ha_lookup "$*" "-f" "echo_dir"
}

# Tab completion for ff command
_ff_completion() {
    local -a dirs
    # Get all matching commands and extract folder basenames for completion
    dirs=($(ha -m '' 2>/dev/null | while read cmd; do ha -f "$cmd" 2>/dev/null; done | sed 's|.*/||' | sort -u))
    _describe 'directories' dirs
}

# Tab completion for fp and fd commands (reuse ff completion)
_fp_fd_completion() {
    local -a commands
    # Get all matching commands for completion
    commands=($(ha -m '' 2>/dev/null))
    _describe 'commands' commands
}

compdef _ff_completion ff
compdef _fp_fd_completion fp
compdef _fp_fd_completion fd